(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_sexp_conv.cmo  pr_o.cmo /tmp/xxx.ml  *)
open Ast_c
open Sexplib

(*
let sexp_of_program x =
  raise (Common.Todo)
*)

(* pad addons: *)
module Common = Sexp_common
module Ast_cocci = struct
let mcodekind_of_sexp x = failwith "todo"
let sexp_of_mcodekind x = failwith "todo"
let fixpos_of_sexp x = failwith "todo"
let sexp_of_fixpos x = failwith "todo"
end
module Token_c = struct
let comment_like_token_of_sexp x = failwith "todo"
let sexp_of_comment_like_token x = failwith "todo"
end
(* cf also the failwith and comment I have added in this file
   (C-s failwith   et C-s ( *        )
   mainly to break the mutually recursive, for the cocci_tag and
   metavars_binding stuff. I also moved some function up
   outside the big 'rec .. and .. and .. and', especially the wrap_of_sexp
   by transforming some 'and xxx' in 'let xxx'.
*)

let show_info = ref false
let show_qualifier = ref false
let show_expr_info = ref true



let posl_of_sexp__ =
  let _loc = "Xxx.posl"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = Conv.int_of_sexp v1 and v2 = Conv.int_of_sexp v2 in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp

let posl_of_sexp sexp =
  try posl_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp

let sexp_of_posl (v1, v2) =
  let v1 = Conv.sexp_of_int v1
  and v2 = Conv.sexp_of_int v2
  in Sexp.List [ v1; v2 ]

let virtual_position_of_sexp__ =
  let _loc = "Xxx.virtual_position"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = Common.parse_info_of_sexp v1
        and v2 = Conv.int_of_sexp v2
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp

let virtual_position_of_sexp sexp =
  try virtual_position_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp

let sexp_of_virtual_position (v1, v2) =
  let v1 = Common.sexp_of_parse_info v1
  and v2 = Conv.sexp_of_int v2
  in Sexp.List [ v1; v2 ]

let parse_info_of_sexp__ =
  let _loc = "Xxx.parse_info"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("originTok" | "OriginTok" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Common.parse_info_of_sexp v1 in OriginTok v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("fakeTok" | "FakeTok" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.string_of_sexp v1
             and v2 = virtual_position_of_sexp v2
             in FakeTok ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("expandedTok" | "ExpandedTok" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Common.parse_info_of_sexp v1
             and v2 = virtual_position_of_sexp v2
             in ExpandedTok ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("abstractLineTok" | "AbstractLineTok" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = Common.parse_info_of_sexp v1 in AbstractLineTok v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("originTok" | "OriginTok") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("fakeTok" | "FakeTok") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("expandedTok" | "ExpandedTok") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("abstractLineTok" | "AbstractLineTok") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp

let parse_info_of_sexp sexp = parse_info_of_sexp__ sexp

let sexp_of_parse_info =
  function
  | OriginTok v1 ->
      let v1 = Common.sexp_of_parse_info v1
      in Sexp.List [ Sexp.Atom "OriginTok"; v1 ]
  | FakeTok ((v1, v2)) ->
      let v1 = Conv.sexp_of_string v1
      and v2 = sexp_of_virtual_position v2
      in Sexp.List [ Sexp.Atom "FakeTok"; v1; v2 ]
  | ExpandedTok ((v1, v2)) ->
      let v1 = Common.sexp_of_parse_info v1
      and v2 = sexp_of_virtual_position v2
      in Sexp.List [ Sexp.Atom "ExpandedTok"; v1; v2 ]
  | AbstractLineTok v1 ->
      let v1 = Common.sexp_of_parse_info v1
      in Sexp.List [ Sexp.Atom "AbstractLineTok"; v1 ]

let rec info_of_sexp__ =
  let _loc = "Xxx.info"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let pinfo_field = ref None and cocci_tag_field = ref None
        and comments_tag_field = ref None and duplicates = ref []
        and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "pinfo" ->
                     (match !pinfo_field with
                      | None ->
                          let fvalue = parse_info_of_sexp field_sexp
                          in pinfo_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "cocci_tag" ->
                     (match !cocci_tag_field with
                      | None ->
                          let fvalue =
                            Conv.ref_of_sexp
                              (Conv.option_of_sexp
                                 (function
                                  | Sexp.List ([ v1; v2 ]) ->
                                      let v1 = Ast_cocci.mcodekind_of_sexp v1
                                      and v2 =
                                        (*metavars_binding_of_sexp v2*)
                                        failwith "todo"
                                      in (v1, v2)
                                  | sexp ->
                                      Conv_error.tuple_of_size_n_expected
                                        _loc 2 sexp))
                              field_sexp
                          in cocci_tag_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "comments_tag" ->
                     (match !comments_tag_field with
                      | None ->
                          let fvalue =
                            Conv.ref_of_sexp comments_around_of_sexp
                              field_sexp
                          in comments_tag_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!pinfo_field), (!cocci_tag_field),
                       (!comments_tag_field))
                with
                | (Some pinfo_value, Some cocci_tag_value,
                   Some comments_tag_value) ->
                    {
                      pinfo = pinfo_value;
                      cocci_tag = cocci_tag_value;
                      comments_tag = comments_tag_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!pinfo_field = None), "pinfo");
                        ((!cocci_tag_field = None), "cocci_tag");
                        ((!comments_tag_field = None), "comments_tag") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and info_of_sexp sexp = info_of_sexp__ sexp
and il_of_sexp__ =
  let _loc = "Xxx.il" in fun sexp -> Conv.list_of_sexp info_of_sexp sexp
and il_of_sexp sexp =
  try il_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and wrap_of_sexp__ =
  let _loc = "Xxx.wrap"
  in
    fun _of_a ->
      function
      | Sexp.List ([ v1; v2 ]) ->
          let v1 = _of_a v1 and v2 = il_of_sexp v2 in (v1, v2)
      | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and wrap_of_sexp _of_a sexp =
  try wrap_of_sexp__ _of_a sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and wrap2_of_sexp__ =
  let _loc = "Xxx.wrap2"
  in
    fun _of_a ->
      function
      | Sexp.List ([ v1; v2 ]) ->
          let v1 = _of_a v1 and v2 = il_of_sexp v2 in (v1, v2)
      | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and wrap2_of_sexp _of_a sexp =
  try wrap2_of_sexp__ _of_a sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp

(* moved up *)
and comments_around_of_sexp__ =
  let _loc = "Xxx.comments_around"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let mbefore_field = ref None and mafter_field = ref None
        and mbefore2_field = ref None and mafter2_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "mbefore" ->
                     (match !mbefore_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp Token_c.
                              comment_like_token_of_sexp field_sexp
                          in mbefore_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "mafter" ->
                     (match !mafter_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp Token_c.
                              comment_like_token_of_sexp field_sexp
                          in mafter_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "mbefore2" ->
                     (match !mbefore2_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp
                              comment_and_relative_pos_of_sexp field_sexp
                          in mbefore2_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "mafter2" ->
                     (match !mafter2_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp
                              comment_and_relative_pos_of_sexp field_sexp
                          in mafter2_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!mbefore_field), (!mafter_field), (!mbefore2_field),
                       (!mafter2_field))
                with
                | (Some mbefore_value, Some mafter_value,
                   Some mbefore2_value, Some mafter2_value) ->
                    {
                      mbefore = mbefore_value;
                      mafter = mafter_value;
                      mbefore2 = mbefore2_value;
                      mafter2 = mafter2_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!mbefore_field = None), "mbefore");
                        ((!mafter_field = None), "mafter");
                        ((!mbefore2_field = None), "mbefore2");
                        ((!mafter2_field = None), "mafter2") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and comments_around_of_sexp sexp = comments_around_of_sexp__ sexp
and comment_and_relative_pos_of_sexp__ =
  let _loc = "Xxx.comment_and_relative_pos"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let minfo_field = ref None and mpos_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "minfo" ->
                     (match !minfo_field with
                      | None ->
                          let fvalue = Common.parse_info_of_sexp field_sexp
                          in minfo_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "mpos" ->
                     (match !mpos_field with
                      | None ->
                          let fvalue = Conv.int_of_sexp field_sexp
                          in mpos_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!minfo_field), (!mpos_field)) with
                | (Some minfo_value, Some mpos_value) ->
                    { minfo = minfo_value; mpos = mpos_value; }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!minfo_field = None), "minfo");
                        ((!mpos_field = None), "mpos") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and comment_and_relative_pos_of_sexp sexp =
  comment_and_relative_pos_of_sexp__ sexp
and comment_of_sexp__ =
  let _loc = "Xxx.comment" in fun sexp -> Common.parse_info_of_sexp sexp
and comment_of_sexp sexp =
  try comment_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and com_of_sexp__ =
  let _loc = "Xxx.com"
  in fun sexp -> Conv.ref_of_sexp (Conv.list_of_sexp comment_of_sexp) sexp
and com_of_sexp sexp =
  try com_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp







(* break let rec  ... and with the previous info *)
let rec name_of_sexp__ =
  let _loc = "Xxx.name"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("regularName" | "RegularName" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = wrap_of_sexp Conv.string_of_sexp v1 in RegularName v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("cppConcatenatedName" | "CppConcatenatedName" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               Conv.list_of_sexp
                 (wrap2_of_sexp (wrap_of_sexp Conv.string_of_sexp)) v1
             in CppConcatenatedName v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("cppVariadicName" | "CppVariadicName" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = wrap_of_sexp Conv.string_of_sexp v1
             in CppVariadicName v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("cppIdentBuilder" | "CppIdentBuilder" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = wrap_of_sexp Conv.string_of_sexp v1
             and v2 =
               Conv.list_of_sexp
                 (wrap2_of_sexp (wrap_of_sexp Conv.string_of_sexp)) v2
             in CppIdentBuilder ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("regularName" | "RegularName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppConcatenatedName" | "CppConcatenatedName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppVariadicName" | "CppVariadicName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppIdentBuilder" | "CppIdentBuilder") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and name_of_sexp sexp = name_of_sexp__ sexp
and fullType_of_sexp__ =
  let _loc = "Xxx.fullType"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = typeQualifier_of_sexp v1
        and v2 = typeC_of_sexp v2
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and fullType_of_sexp sexp =
  try fullType_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and typeC_of_sexp__ =
  let _loc = "Xxx.typeC" in fun sexp -> wrap_of_sexp typeCbis_of_sexp sexp
and typeC_of_sexp sexp =
  try typeC_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and typeCbis_of_sexp__ =
  let _loc = "Xxx.typeCbis"
  in
    function
    | (Sexp.List (Sexp.Atom (("baseType" | "BaseType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = baseType_of_sexp v1 in BaseType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("pointer" | "Pointer" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in Pointer v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("array" | "Array" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.option_of_sexp constExpression_of_sexp v1
             and v2 = fullType_of_sexp v2
             in Array ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("functionType" | "FunctionType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = functionType_of_sexp v1 in FunctionType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("enum" | "Enum" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.option_of_sexp Conv.string_of_sexp v1
             and v2 = enumType_of_sexp v2
             in Enum ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("structUnion" | "StructUnion" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = structUnion_of_sexp v1
             and v2 = Conv.option_of_sexp Conv.string_of_sexp v2
             and v3 = structType_of_sexp v3
             in StructUnion ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("enumName" | "EnumName" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in EnumName v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("structUnionName" | "StructUnionName" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = structUnion_of_sexp v1
             and v2 = Conv.string_of_sexp v2
             in StructUnionName ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("typeName" | "TypeName" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = name_of_sexp v1
             and v2 = Conv.option_of_sexp fullType_of_sexp v2
             in TypeName ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("parenType" | "ParenType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in ParenType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("typeOfExpr" | "TypeOfExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in TypeOfExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("typeOfType" | "TypeOfType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in TypeOfType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("baseType" | "BaseType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("pointer" | "Pointer") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("array" | "Array") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("functionType" | "FunctionType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("enum" | "Enum") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("structUnion" | "StructUnion") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("enumName" | "EnumName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("structUnionName" | "StructUnionName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("typeName" | "TypeName") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("parenType" | "ParenType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("typeOfExpr" | "TypeOfExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("typeOfType" | "TypeOfType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and typeCbis_of_sexp sexp = typeCbis_of_sexp__ sexp
and baseType_of_sexp__ =
  let _loc = "Xxx.baseType"
  in
    function
    | Sexp.Atom ("void" | "Void") -> Void
    | (Sexp.List (Sexp.Atom (("intType" | "IntType" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = intType_of_sexp v1 in IntType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("floatType" | "FloatType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = floatType_of_sexp v1 in FloatType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("void" | "Void") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("intType" | "IntType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("floatType" | "FloatType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and baseType_of_sexp sexp = baseType_of_sexp__ sexp
and intType_of_sexp__ =
  let _loc = "Xxx.intType"
  in
    function
    | Sexp.Atom ("cChar" | "CChar") -> CChar
    | (Sexp.List (Sexp.Atom (("si" | "Si" as tag)) :: sexp_args) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = signed_of_sexp v1 in Si v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("cChar" | "CChar") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("si" | "Si") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and intType_of_sexp sexp = intType_of_sexp__ sexp
and signed_of_sexp__ =
  let _loc = "Xxx.signed"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = sign_of_sexp v1 and v2 = base_of_sexp v2 in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and signed_of_sexp sexp =
  try signed_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and base_of_sexp__ =
  let _loc = "Xxx.base"
  in
    function
    | Sexp.Atom ("cChar2" | "CChar2") -> CChar2
    | Sexp.Atom ("cShort" | "CShort") -> CShort
    | Sexp.Atom ("cInt" | "CInt") -> CInt
    | Sexp.Atom ("cLong" | "CLong") -> CLong
    | Sexp.Atom ("cLongLong" | "CLongLong") -> CLongLong
    | (Sexp.List (Sexp.Atom ("cChar2" | "CChar2") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cShort" | "CShort") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cInt" | "CInt") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cLong" | "CLong") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cLongLong" | "CLongLong") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and base_of_sexp sexp = base_of_sexp__ sexp
and sign_of_sexp__ =
  let _loc = "Xxx.sign"
  in
    function
    | Sexp.Atom ("signed" | "Signed") -> Signed
    | Sexp.Atom ("unSigned" | "UnSigned") -> UnSigned
    | (Sexp.List (Sexp.Atom ("signed" | "Signed") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("unSigned" | "UnSigned") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and sign_of_sexp sexp = sign_of_sexp__ sexp
and floatType_of_sexp__ =
  let _loc = "Xxx.floatType"
  in
    function
    | Sexp.Atom ("cFloat" | "CFloat") -> CFloat
    | Sexp.Atom ("cDouble" | "CDouble") -> CDouble
    | Sexp.Atom ("cLongDouble" | "CLongDouble") -> CLongDouble
    | (Sexp.List (Sexp.Atom ("cFloat" | "CFloat") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cDouble" | "CDouble") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("cLongDouble" | "CLongDouble") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and floatType_of_sexp sexp = floatType_of_sexp__ sexp
and structUnion_of_sexp__ =
  let _loc = "Xxx.structUnion"
  in
    function
    | Sexp.Atom ("struct" | "Struct") -> Struct
    | Sexp.Atom ("union" | "Union") -> Union
    | (Sexp.List (Sexp.Atom ("struct" | "Struct") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("union" | "Union") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and structUnion_of_sexp sexp = structUnion_of_sexp__ sexp
and structType_of_sexp__ =
  let _loc = "Xxx.structType"
  in fun sexp -> Conv.list_of_sexp field_of_sexp sexp
and structType_of_sexp sexp =
  try structType_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and field_of_sexp__ =
  let _loc = "Xxx.field"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("declarationField" | "DeclarationField" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = field_declaration_of_sexp v1 in DeclarationField v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("emptyField" | "EmptyField" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = info_of_sexp v1 in EmptyField v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("macroDeclField" | "MacroDeclField" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (function
                  | Sexp.List ([ v1; v2 ]) ->
                      let v1 = Conv.string_of_sexp v1
                      and v2 =
                        Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v2
                      in (v1, v2)
                  | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
                 v1
             in MacroDeclField v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("cppDirectiveStruct" | "CppDirectiveStruct" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = cpp_directive_of_sexp v1 in CppDirectiveStruct v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("ifdefStruct" | "IfdefStruct" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = ifdef_directive_of_sexp v1 in IfdefStruct v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("declarationField" | "DeclarationField") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("emptyField" | "EmptyField") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("macroDeclField" | "MacroDeclField") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppDirectiveStruct" | "CppDirectiveStruct") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("ifdefStruct" | "IfdefStruct") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and field_of_sexp sexp = field_of_sexp__ sexp
and field_declaration_of_sexp__ =
  let _loc = "Xxx.field_declaration"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("fieldDeclList" | "FieldDeclList" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (Conv.list_of_sexp (wrap2_of_sexp fieldkind_of_sexp)) v1
             in FieldDeclList v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("fieldDeclList" | "FieldDeclList") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and field_declaration_of_sexp sexp = field_declaration_of_sexp__ sexp
and fieldkind_of_sexp__ =
  let _loc = "Xxx.fieldkind"
  in
    function
    | (Sexp.List (Sexp.Atom (("simple" | "Simple" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.option_of_sexp name_of_sexp v1
             and v2 = fullType_of_sexp v2
             in Simple ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("bitField" | "BitField" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3; v4 ] ->
             let v1 = Conv.option_of_sexp name_of_sexp v1
             and v2 = fullType_of_sexp v2
             and v3 = info_of_sexp v3
             and v4 = constExpression_of_sexp v4
             in BitField ((v1, v2, v3, v4))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("simple" | "Simple") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("bitField" | "BitField") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and fieldkind_of_sexp sexp = fieldkind_of_sexp__ sexp

and enumType_of_sexp__ =
  let _loc = "Xxx.enumType"
  in
    fun sexp ->
      Conv.list_of_sexp
        (wrap2_of_sexp
           (function
            | Sexp.List ([ v1; v2 ]) ->
                let v1 = name_of_sexp v1
                and v2 =
                  Conv.option_of_sexp
                    (function
                     | Sexp.List ([ v1; v2 ]) ->
                         let v1 = info_of_sexp v1
                         and v2 = constExpression_of_sexp v2
                         in (v1, v2)
                     | sexp ->
                         Conv_error.tuple_of_size_n_expected _loc 2 sexp)
                    v2
                in (v1, v2)
            | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp))
        sexp
and enumType_of_sexp sexp =
  try enumType_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and functionType_of_sexp__ =
  let _loc = "Xxx.functionType"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = fullType_of_sexp v1
        and v2 =
          (match v2 with
           | Sexp.List ([ v1; v2 ]) ->
               let v1 =
                 Conv.list_of_sexp (wrap2_of_sexp parameterType_of_sexp) v1
               and v2 = wrap_of_sexp Conv.bool_of_sexp v2
               in (v1, v2)
           | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and functionType_of_sexp sexp =
  try functionType_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and parameterType_of_sexp__ =
  let _loc = "Xxx.parameterType"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let p_namei_field = ref None and p_register_field = ref None
        and p_type_field = ref None and duplicates = ref []
        and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "p_namei" ->
                     (match !p_namei_field with
                      | None ->
                          let fvalue =
                            Conv.option_of_sexp name_of_sexp field_sexp
                          in p_namei_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "p_register" ->
                     (match !p_register_field with
                      | None ->
                          let fvalue =
                            wrap_of_sexp Conv.bool_of_sexp field_sexp
                          in p_register_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "p_type" ->
                     (match !p_type_field with
                      | None ->
                          let fvalue = fullType_of_sexp field_sexp
                          in p_type_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!p_namei_field), (!p_register_field),
                       (!p_type_field))
                with
                | (Some p_namei_value, Some p_register_value,
                   Some p_type_value) ->
                    {
                      p_namei = p_namei_value;
                      p_register = p_register_value;
                      p_type = p_type_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!p_namei_field = None), "p_namei");
                        ((!p_register_field = None), "p_register");
                        ((!p_type_field = None), "p_type") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and parameterType_of_sexp sexp = parameterType_of_sexp__ sexp
and typeQualifier_of_sexp__ =
  let _loc = "Xxx.typeQualifier"
  in fun sexp -> wrap_of_sexp typeQualifierbis_of_sexp sexp
and typeQualifier_of_sexp sexp =
  try typeQualifier_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and typeQualifierbis_of_sexp__ =
  let _loc = "Xxx.typeQualifierbis"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let const_field = ref None and volatile_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "const" ->
                     (match !const_field with
                      | None ->
                          let fvalue = Conv.bool_of_sexp field_sexp
                          in const_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "volatile" ->
                     (match !volatile_field with
                      | None ->
                          let fvalue = Conv.bool_of_sexp field_sexp
                          in volatile_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!const_field), (!volatile_field)) with
                | (Some const_value, Some volatile_value) ->
                    { const = const_value; volatile = volatile_value; }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!const_field = None), "const");
                        ((!volatile_field = None), "volatile") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and typeQualifierbis_of_sexp sexp = typeQualifierbis_of_sexp__ sexp
and attribute_of_sexp__ =
  let _loc = "Xxx.attribute"
  in fun sexp -> wrap_of_sexp attributebis_of_sexp sexp
and attribute_of_sexp sexp =
  try attribute_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and attributebis_of_sexp__ =
  let _loc = "Xxx.attributebis"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("attribute" | "Attribute" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in Attribute v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("attribute" | "Attribute") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and attributebis_of_sexp sexp = attributebis_of_sexp__ sexp
and expression_of_sexp__ =
  let _loc = "Xxx.expression"
  in
    fun sexp ->
      wrap_of_sexp
        (function
         | Sexp.List ([ v1; v2 ]) ->
             let v1 = expressionbis_of_sexp v1
             and v2 = Conv.ref_of_sexp exp_info_of_sexp v2
             in (v1, v2)
         | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
        sexp
and expression_of_sexp sexp =
  try expression_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and exp_info_of_sexp__ =
  let _loc = "Xxx.exp_info"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = Conv.option_of_sexp exp_type_of_sexp v1
        and v2 = test_of_sexp v2
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and exp_info_of_sexp sexp =
  try exp_info_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and exp_type_of_sexp__ =
  let _loc = "Xxx.exp_type"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = fullType_of_sexp v1 and v2 = local_of_sexp v2 in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and exp_type_of_sexp sexp =
  try exp_type_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and local_of_sexp__ =
  let _loc = "Xxx.local"
  in
    function
    | (Sexp.List (Sexp.Atom (("localVar" | "LocalVar" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = parse_info_of_sexp v1 in LocalVar v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | Sexp.Atom ("notLocalVar" | "NotLocalVar") -> NotLocalVar
    | (Sexp.Atom ("localVar" | "LocalVar") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.Atom ("notLocalVar" | "NotLocalVar") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and local_of_sexp sexp = local_of_sexp__ sexp
and test_of_sexp__ =
  let _loc = "Xxx.test"
  in
    function
    | Sexp.Atom ("test" | "Test") -> Test
    | Sexp.Atom ("notTest" | "NotTest") -> NotTest
    | (Sexp.List (Sexp.Atom ("test" | "Test") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("notTest" | "NotTest") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and test_of_sexp sexp = test_of_sexp__ sexp
and expressionbis_of_sexp__ =
  let _loc = "Xxx.expressionbis"
  in
    function
    | (Sexp.List (Sexp.Atom (("ident" | "Ident" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = name_of_sexp v1 in Ident v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("constant" | "Constant" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = constant_of_sexp v1 in Constant v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("funCall" | "FunCall" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v2
             in FunCall ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("condExpr" | "CondExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = expression_of_sexp v1
             and v2 = Conv.option_of_sexp expression_of_sexp v2
             and v3 = expression_of_sexp v3
             in CondExpr ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("sequence" | "Sequence" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = expression_of_sexp v2
             in Sequence ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("assignment" | "Assignment" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = expression_of_sexp v1
             and v2 = assignOp_of_sexp v2
             and v3 = expression_of_sexp v3
             in Assignment ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("postfix" | "Postfix" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = fixOp_of_sexp v2
             in Postfix ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("infix" | "Infix" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = fixOp_of_sexp v2
             in Infix ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("unary" | "Unary" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = unaryOp_of_sexp v2
             in Unary ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("binary" | "Binary" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = expression_of_sexp v1
             and v2 = binaryOp_of_sexp v2
             and v3 = expression_of_sexp v3
             in Binary ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("arrayAccess" | "ArrayAccess" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = expression_of_sexp v2
             in ArrayAccess ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("recordAccess" | "RecordAccess" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = name_of_sexp v2
             in RecordAccess ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("recordPtAccess" | "RecordPtAccess" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = name_of_sexp v2
             in RecordPtAccess ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("sizeOfExpr" | "SizeOfExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in SizeOfExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("sizeOfType" | "SizeOfType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in SizeOfType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("cast" | "Cast" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = fullType_of_sexp v1
             and v2 = expression_of_sexp v2
             in Cast ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("statementExpr" | "StatementExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = wrap_of_sexp compound_of_sexp v1 in StatementExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("constructor" | "Constructor" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = fullType_of_sexp v1
             and v2 =
               Conv.list_of_sexp (wrap2_of_sexp initialiser_of_sexp) v2
             in Constructor ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("parenExpr" | "ParenExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in ParenExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("ident" | "Ident") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("constant" | "Constant") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("funCall" | "FunCall") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("condExpr" | "CondExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("sequence" | "Sequence") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("assignment" | "Assignment") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("postfix" | "Postfix") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("infix" | "Infix") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("unary" | "Unary") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("binary" | "Binary") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("arrayAccess" | "ArrayAccess") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("recordAccess" | "RecordAccess") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("recordPtAccess" | "RecordPtAccess") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("sizeOfExpr" | "SizeOfExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("sizeOfType" | "SizeOfType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cast" | "Cast") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("statementExpr" | "StatementExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("constructor" | "Constructor") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("parenExpr" | "ParenExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and expressionbis_of_sexp sexp = expressionbis_of_sexp__ sexp
and argument_of_sexp__ =
  let _loc = "Xxx.argument"
  in
    fun sexp -> Common.either_of_sexp expression_of_sexp weird_argument_of_sexp sexp
and argument_of_sexp sexp =
  try argument_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and weird_argument_of_sexp__ =
  let _loc = "Xxx.weird_argument"
  in
    function
    | (Sexp.List (Sexp.Atom (("argType" | "ArgType" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = parameterType_of_sexp v1 in ArgType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("argAction" | "ArgAction" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = action_macro_of_sexp v1 in ArgAction v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("argType" | "ArgType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("argAction" | "ArgAction") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and weird_argument_of_sexp sexp = weird_argument_of_sexp__ sexp
and action_macro_of_sexp__ =
  let _loc = "Xxx.action_macro"
  in
    function
    | (Sexp.List (Sexp.Atom (("actMisc" | "ActMisc" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = il_of_sexp v1 in ActMisc v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("actMisc" | "ActMisc") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and action_macro_of_sexp sexp = action_macro_of_sexp__ sexp
and constant_of_sexp__ =
  let _loc = "Xxx.constant"
  in
    function
    | (Sexp.List (Sexp.Atom (("string" | "String" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               (match v1 with
                | Sexp.List ([ v1; v2 ]) ->
                    let v1 = Conv.string_of_sexp v1
                    and v2 = isWchar_of_sexp v2
                    in (v1, v2)
                | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
             in String v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("multiString" | "MultiString" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = Conv.list_of_sexp Conv.string_of_sexp v1
             in MultiString v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("char" | "Char" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               (match v1 with
                | Sexp.List ([ v1; v2 ]) ->
                    let v1 = Conv.string_of_sexp v1
                    and v2 = isWchar_of_sexp v2
                    in (v1, v2)
                | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
             in Char v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("int" | "Int" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in Int (v1, failwith "Todo")
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("float" | "Float" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               (match v1 with
                | Sexp.List ([ v1; v2 ]) ->
                    let v1 = Conv.string_of_sexp v1
                    and v2 = floatType_of_sexp v2
                    in (v1, v2)
                | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
             in Float v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("string" | "String") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("multiString" | "MultiString") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("char" | "Char") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("int" | "Int") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("float" | "Float") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and constant_of_sexp sexp = constant_of_sexp__ sexp
and isWchar_of_sexp__ =
  let _loc = "Xxx.isWchar"
  in
    function
    | Sexp.Atom ("isWchar" | "IsWchar") -> IsWchar
    | Sexp.Atom ("isChar" | "IsChar") -> IsChar
    | (Sexp.List (Sexp.Atom ("isWchar" | "IsWchar") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("isChar" | "IsChar") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and isWchar_of_sexp sexp = isWchar_of_sexp__ sexp
and unaryOp_of_sexp__ =
  let _loc = "Xxx.unaryOp"
  in
    function
    | Sexp.Atom ("getRef" | "GetRef") -> GetRef
    | Sexp.Atom ("deRef" | "DeRef") -> DeRef
    | Sexp.Atom ("unPlus" | "UnPlus") -> UnPlus
    | Sexp.Atom ("unMinus" | "UnMinus") -> UnMinus
    | Sexp.Atom ("tilde" | "Tilde") -> Tilde
    | Sexp.Atom ("not" | "Not") -> Not
    | Sexp.Atom ("getRefLabel" | "GetRefLabel") -> GetRefLabel
    | (Sexp.List (Sexp.Atom ("getRef" | "GetRef") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("deRef" | "DeRef") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("unPlus" | "UnPlus") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("unMinus" | "UnMinus") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("tilde" | "Tilde") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("not" | "Not") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("getRefLabel" | "GetRefLabel") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and unaryOp_of_sexp sexp = unaryOp_of_sexp__ sexp
and assignOp_of_sexp__ =
  let _loc = "Xxx.assignOp"
  in
    function
    | Sexp.Atom ("simpleAssign" | "SimpleAssign") -> SimpleAssign
    | (Sexp.List (Sexp.Atom (("opAssign" | "OpAssign" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = arithOp_of_sexp v1 in OpAssign v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("simpleAssign" | "SimpleAssign") :: _) as sexp)
        -> Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("opAssign" | "OpAssign") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and assignOp_of_sexp sexp = assignOp_of_sexp__ sexp
and fixOp_of_sexp__ =
  let _loc = "Xxx.fixOp"
  in
    function
    | Sexp.Atom ("dec" | "Dec") -> Dec
    | Sexp.Atom ("inc" | "Inc") -> Inc
    | (Sexp.List (Sexp.Atom ("dec" | "Dec") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("inc" | "Inc") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and fixOp_of_sexp sexp = fixOp_of_sexp__ sexp
and binaryOp_of_sexp__ =
  let _loc = "Xxx.binaryOp"
  in
    function
    | (Sexp.List (Sexp.Atom (("arith" | "Arith" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = arithOp_of_sexp v1 in Arith v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("logical" | "Logical" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = logicalOp_of_sexp v1 in Logical v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("arith" | "Arith") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("logical" | "Logical") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and binaryOp_of_sexp sexp = binaryOp_of_sexp__ sexp
and arithOp_of_sexp__ =
  let _loc = "Xxx.arithOp"
  in
    function
    | Sexp.Atom ("plus" | "Plus") -> Plus
    | Sexp.Atom ("minus" | "Minus") -> Minus
    | Sexp.Atom ("mul" | "Mul") -> Mul
    | Sexp.Atom ("div" | "Div") -> Div
    | Sexp.Atom ("mod" | "Mod") -> Mod
    | Sexp.Atom ("decLeft" | "DecLeft") -> DecLeft
    | Sexp.Atom ("decRight" | "DecRight") -> DecRight
    | Sexp.Atom ("and" | "And") -> And
    | Sexp.Atom ("or" | "Or") -> Or
    | Sexp.Atom ("xor" | "Xor") -> Xor
    | (Sexp.List (Sexp.Atom ("plus" | "Plus") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("minus" | "Minus") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("mul" | "Mul") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("div" | "Div") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("mod" | "Mod") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("decLeft" | "DecLeft") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("decRight" | "DecRight") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("and" | "And") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("or" | "Or") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("xor" | "Xor") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and arithOp_of_sexp sexp = arithOp_of_sexp__ sexp
and logicalOp_of_sexp__ =
  let _loc = "Xxx.logicalOp"
  in
    function
    | Sexp.Atom ("inf" | "Inf") -> Inf
    | Sexp.Atom ("sup" | "Sup") -> Sup
    | Sexp.Atom ("infEq" | "InfEq") -> InfEq
    | Sexp.Atom ("supEq" | "SupEq") -> SupEq
    | Sexp.Atom ("eq" | "Eq") -> Eq
    | Sexp.Atom ("notEq" | "NotEq") -> NotEq
    | Sexp.Atom ("andLog" | "AndLog") -> AndLog
    | Sexp.Atom ("orLog" | "OrLog") -> OrLog
    | (Sexp.List (Sexp.Atom ("inf" | "Inf") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("sup" | "Sup") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("infEq" | "InfEq") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("supEq" | "SupEq") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("eq" | "Eq") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("notEq" | "NotEq") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("andLog" | "AndLog") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("orLog" | "OrLog") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and logicalOp_of_sexp sexp = logicalOp_of_sexp__ sexp
and constExpression_of_sexp__ =
  let _loc = "Xxx.constExpression" in fun sexp -> expression_of_sexp sexp
and constExpression_of_sexp sexp =
  try constExpression_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and statement_of_sexp__ =
  let _loc = "Xxx.statement"
  in fun sexp -> wrap_of_sexp statementbis_of_sexp sexp
and statement_of_sexp sexp =
  try statement_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and statementbis_of_sexp__ =
  let _loc = "Xxx.statementbis"
  in
    function
    | (Sexp.List (Sexp.Atom (("labeled" | "Labeled" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = labeled_of_sexp v1 in Labeled v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("compound" | "Compound" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = compound_of_sexp v1 in Compound v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("exprStatement" | "ExprStatement" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = exprStatement_of_sexp v1 in ExprStatement v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("selection" | "Selection" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = selection_of_sexp v1 in Selection v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("iteration" | "Iteration" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = iteration_of_sexp v1 in Iteration v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("jump" | "Jump" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = jump_of_sexp v1 in Jump v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("decl" | "Decl" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = declaration_of_sexp v1 in Decl v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("asm" | "Asm" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = asmbody_of_sexp v1 in Asm v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("nestedFunc" | "NestedFunc" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = definition_of_sexp v1 in NestedFunc v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | Sexp.Atom ("macroStmt" | "MacroStmt") -> MacroStmt
    | (Sexp.Atom ("labeled" | "Labeled") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("compound" | "Compound") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("exprStatement" | "ExprStatement") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("selection" | "Selection") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("iteration" | "Iteration") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("jump" | "Jump") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("decl" | "Decl") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("asm" | "Asm") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("nestedFunc" | "NestedFunc") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.Atom ("macroStmt" | "MacroStmt") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and statementbis_of_sexp sexp = statementbis_of_sexp__ sexp
and labeled_of_sexp__ =
  let _loc = "Xxx.labeled"
  in
    function
    | (Sexp.List (Sexp.Atom (("label" | "Label" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = name_of_sexp v1
             and v2 = statement_of_sexp v2
             in Label ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("case" | "Case" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = statement_of_sexp v2
             in Case ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("caseRange" | "CaseRange" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = expression_of_sexp v1
             and v2 = expression_of_sexp v2
             and v3 = statement_of_sexp v3
             in CaseRange ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("default" | "Default" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = statement_of_sexp v1 in Default v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("label" | "Label") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("case" | "Case") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("caseRange" | "CaseRange") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("default" | "Default") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and labeled_of_sexp sexp = labeled_of_sexp__ sexp
and compound_of_sexp__ =
  let _loc = "Xxx.compound"
  in fun sexp -> Conv.list_of_sexp statement_sequencable_of_sexp sexp
and compound_of_sexp sexp =
  try compound_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and statement_sequencable_of_sexp__ =
  let _loc = "Xxx.statement_sequencable"
  in
    function
    | (Sexp.List (Sexp.Atom (("stmtElem" | "StmtElem" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = statement_of_sexp v1 in StmtElem v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("cppDirectiveStmt" | "CppDirectiveStmt" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = cpp_directive_of_sexp v1 in CppDirectiveStmt v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("ifdefStmt" | "IfdefStmt" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = ifdef_directive_of_sexp v1 in IfdefStmt v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("ifdefStmt2" | "IfdefStmt2" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.list_of_sexp ifdef_directive_of_sexp v1
             and v2 =
               Conv.list_of_sexp
                 (Conv.list_of_sexp statement_sequencable_of_sexp) v2
             in IfdefStmt2 ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("stmtElem" | "StmtElem") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppDirectiveStmt" | "CppDirectiveStmt") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("ifdefStmt" | "IfdefStmt") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("ifdefStmt2" | "IfdefStmt2") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and statement_sequencable_of_sexp sexp = statement_sequencable_of_sexp__ sexp
and exprStatement_of_sexp__ =
  let _loc = "Xxx.exprStatement"
  in fun sexp -> Conv.option_of_sexp expression_of_sexp sexp
and exprStatement_of_sexp sexp =
  try exprStatement_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and selection_of_sexp__ =
  let _loc = "Xxx.selection"
  in
    function
    | (Sexp.List (Sexp.Atom (("if" | "If" as tag)) :: sexp_args) as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = expression_of_sexp v1
             and v2 = statement_of_sexp v2
             and v3 = statement_of_sexp v3
             in If ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("switch" | "Switch" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = statement_of_sexp v2
             in Switch ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("if" | "If") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("switch" | "Switch") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and selection_of_sexp sexp = selection_of_sexp__ sexp
and iteration_of_sexp__ =
  let _loc = "Xxx.iteration"
  in
    function
    | (Sexp.List (Sexp.Atom (("while" | "While" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = statement_of_sexp v2
             in While ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("doWhile" | "DoWhile" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = statement_of_sexp v1
             and v2 = expression_of_sexp v2
             in DoWhile ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("for" | "For" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1; v2; v3; v4 ] ->
             let v1 = wrap_of_sexp exprStatement_of_sexp v1
             and v2 = wrap_of_sexp exprStatement_of_sexp v2
             and v3 = wrap_of_sexp exprStatement_of_sexp v3
             and v4 = statement_of_sexp v4
             in For ((v1, v2, v3, v4))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("macroIteration" | "MacroIteration" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = Conv.string_of_sexp v1
             and v2 = Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v2
             and v3 = statement_of_sexp v3
             in MacroIteration ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("while" | "While") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("doWhile" | "DoWhile") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("for" | "For") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("macroIteration" | "MacroIteration") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and iteration_of_sexp sexp = iteration_of_sexp__ sexp
and jump_of_sexp__ =
  let _loc = "Xxx.jump"
  in
    function
    | (Sexp.List (Sexp.Atom (("goto" | "Goto" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = name_of_sexp v1 in Goto v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | Sexp.Atom ("continue" | "Continue") -> Continue
    | Sexp.Atom ("break" | "Break") -> Break
    | Sexp.Atom ("return" | "Return") -> Return
    | (Sexp.List
         (Sexp.Atom (("returnExpr" | "ReturnExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in ReturnExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("gotoComputed" | "GotoComputed" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in GotoComputed v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("goto" | "Goto") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.Atom ("continue" | "Continue") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("break" | "Break") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("return" | "Return") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("returnExpr" | "ReturnExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("gotoComputed" | "GotoComputed") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and jump_of_sexp sexp = jump_of_sexp__ sexp
and asmbody_of_sexp__ =
  let _loc = "Xxx.asmbody"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = il_of_sexp v1
        and v2 = Conv.list_of_sexp (wrap_of_sexp colon_of_sexp) v2
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and asmbody_of_sexp sexp =
  try asmbody_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and colon_of_sexp__ =
  let _loc = "Xxx.colon"
  in
    function
    | (Sexp.List (Sexp.Atom (("colon" | "Colon" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               Conv.list_of_sexp (wrap2_of_sexp colon_option_of_sexp) v1
             in Colon v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("colon" | "Colon") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and colon_of_sexp sexp = colon_of_sexp__ sexp
and colon_option_of_sexp__ =
  let _loc = "Xxx.colon_option"
  in fun sexp -> wrap_of_sexp colon_option_bis_of_sexp sexp
and colon_option_of_sexp sexp =
  try colon_option_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and colon_option_bis_of_sexp__ =
  let _loc = "Xxx.colon_option_bis"
  in
    function
    | Sexp.Atom ("colonMisc" | "ColonMisc") -> ColonMisc
    | (Sexp.List
         (Sexp.Atom (("colonExpr" | "ColonExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in ColonExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("colonMisc" | "ColonMisc") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("colonExpr" | "ColonExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and colon_option_bis_of_sexp sexp = colon_option_bis_of_sexp__ sexp
and declaration_of_sexp__ =
  let _loc = "Xxx.declaration"
  in
    function
    | (Sexp.List (Sexp.Atom (("declList" | "DeclList" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (Conv.list_of_sexp (wrap2_of_sexp onedecl_of_sexp)) v1
             in DeclList v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("macroDecl" | "MacroDecl" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (function
                  | Sexp.List ([ v1; v2 ]) ->
                      let v1 = Conv.string_of_sexp v1
                      and v2 =
                        Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v2
                      in (v1, v2)
                  | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
                 v1
             in MacroDecl v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("declList" | "DeclList") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("macroDecl" | "MacroDecl") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and declaration_of_sexp sexp = declaration_of_sexp__ sexp
and onedecl_of_sexp__ =
  let _loc = "Xxx.onedecl"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let v_namei_field = ref None and v_type_field = ref None
        and v_type_bis_field = ref None and v_storage_field = ref None
        and v_local_field = ref None and v_attr_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "v_namei" ->
                     (match !v_namei_field with
                      | None ->
                          let fvalue =
                            Conv.option_of_sexp
                              (function
                               | Sexp.List ([ v1; v2 ]) ->
                                   let v1 = name_of_sexp v1
                                   and v2 =
                                     Conv.option_of_sexp
                                       (function
                                        | Sexp.List ([ v1; v2 ]) ->
                                            let v1 = info_of_sexp v1
                                            and v2 = initialiser_of_sexp v2
                                            in (v1, v2)
                                        | sexp ->
                                            Conv_error.
                                              tuple_of_size_n_expected _loc 2
                                              sexp)
                                       v2
                                   in (v1, v2)
                               | sexp ->
                                   Conv_error.tuple_of_size_n_expected _loc 2
                                     sexp)
                              field_sexp
                          in v_namei_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "v_type" ->
                     (match !v_type_field with
                      | None ->
                          let fvalue = fullType_of_sexp field_sexp
                          in v_type_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "v_type_bis" ->
                     (match !v_type_bis_field with
                      | None ->
                          let fvalue =
                            Conv.ref_of_sexp
                              (Conv.option_of_sexp fullType_of_sexp)
                              field_sexp
                          in v_type_bis_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "v_storage" ->
                     (match !v_storage_field with
                      | None ->
                          let fvalue = storage_of_sexp field_sexp
                          in v_storage_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "v_local" ->
                     (match !v_local_field with
                      | None ->
                          let fvalue = local_decl_of_sexp field_sexp
                          in v_local_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "v_attr" ->
                     (match !v_attr_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp attribute_of_sexp field_sexp
                          in v_attr_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!v_namei_field), (!v_type_field),
                       (!v_type_bis_field), (!v_storage_field),
                       (!v_local_field), (!v_attr_field))
                with
                | (Some v_namei_value, Some v_type_value,
                   Some v_type_bis_value, Some v_storage_value,
                   Some v_local_value, Some v_attr_value) ->
                    {
                      v_namei = v_namei_value;
                      v_type = v_type_value;
                      v_type_bis = v_type_bis_value;
                      v_storage = v_storage_value;
                      v_local = v_local_value;
                      v_attr = v_attr_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!v_namei_field = None), "v_namei");
                        ((!v_type_field = None), "v_type");
                        ((!v_type_bis_field = None), "v_type_bis");
                        ((!v_storage_field = None), "v_storage");
                        ((!v_local_field = None), "v_local");
                        ((!v_attr_field = None), "v_attr") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and onedecl_of_sexp sexp = onedecl_of_sexp__ sexp
and storage_of_sexp__ =
  let _loc = "Xxx.storage"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = storagebis_of_sexp v1
        and v2 = Conv.bool_of_sexp v2
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and storage_of_sexp sexp =
  try storage_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and storagebis_of_sexp__ =
  let _loc = "Xxx.storagebis"
  in
    function
    | Sexp.Atom ("noSto" | "NoSto") -> NoSto
    | Sexp.Atom ("stoTypedef" | "StoTypedef") -> StoTypedef
    | (Sexp.List (Sexp.Atom (("sto" | "Sto" as tag)) :: sexp_args) as sexp)
        ->
        (match sexp_args with
         | [ v1 ] -> let v1 = storageClass_of_sexp v1 in Sto v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("noSto" | "NoSto") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("stoTypedef" | "StoTypedef") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("sto" | "Sto") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and storagebis_of_sexp sexp = storagebis_of_sexp__ sexp
and storageClass_of_sexp__ =
  let _loc = "Xxx.storageClass"
  in
    function
    | Sexp.Atom ("auto" | "Auto") -> Auto
    | Sexp.Atom ("static" | "Static") -> Static
    | Sexp.Atom ("register" | "Register") -> Register
    | Sexp.Atom ("extern" | "Extern") -> Extern
    | (Sexp.List (Sexp.Atom ("auto" | "Auto") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("static" | "Static") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("register" | "Register") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("extern" | "Extern") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and storageClass_of_sexp sexp = storageClass_of_sexp__ sexp
and local_decl_of_sexp__ =
  let _loc = "Xxx.local_decl"
  in
    function
    | Sexp.Atom ("localDecl" | "LocalDecl") -> LocalDecl
    | Sexp.Atom ("notLocalDecl" | "NotLocalDecl") -> NotLocalDecl
    | (Sexp.List (Sexp.Atom ("localDecl" | "LocalDecl") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("notLocalDecl" | "NotLocalDecl") :: _) as sexp)
        -> Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and local_decl_of_sexp sexp = local_decl_of_sexp__ sexp
and initialiser_of_sexp__ =
  let _loc = "Xxx.initialiser"
  in fun sexp -> wrap_of_sexp initialiserbis_of_sexp sexp
and initialiser_of_sexp sexp =
  try initialiser_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and initialiserbis_of_sexp__ =
  let _loc = "Xxx.initialiserbis"
  in
    function
    | (Sexp.List (Sexp.Atom (("initExpr" | "InitExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in InitExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("initList" | "InitList" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               Conv.list_of_sexp (wrap2_of_sexp initialiser_of_sexp) v1
             in InitList v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("initDesignators" | "InitDesignators" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.list_of_sexp designator_of_sexp v1
             and v2 = initialiser_of_sexp v2
             in InitDesignators ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("initFieldOld" | "InitFieldOld" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = Conv.string_of_sexp v1
             and v2 = initialiser_of_sexp v2
             in InitFieldOld ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("initIndexOld" | "InitIndexOld" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = initialiser_of_sexp v2
             in InitIndexOld ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("initExpr" | "InitExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("initList" | "InitList") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("initDesignators" | "InitDesignators") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("initFieldOld" | "InitFieldOld") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("initIndexOld" | "InitIndexOld") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and initialiserbis_of_sexp sexp = initialiserbis_of_sexp__ sexp
and designator_of_sexp__ =
  let _loc = "Xxx.designator"
  in fun sexp -> wrap_of_sexp designatorbis_of_sexp sexp
and designator_of_sexp sexp =
  try designator_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and designatorbis_of_sexp__ =
  let _loc = "Xxx.designatorbis"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("designatorField" | "DesignatorField" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in DesignatorField v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("designatorIndex" | "DesignatorIndex" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in DesignatorIndex v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("designatorRange" | "DesignatorRange" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2 ] ->
             let v1 = expression_of_sexp v1
             and v2 = expression_of_sexp v2
             in DesignatorRange ((v1, v2))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("designatorField" | "DesignatorField") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("designatorIndex" | "DesignatorIndex") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("designatorRange" | "DesignatorRange") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and designatorbis_of_sexp sexp = designatorbis_of_sexp__ sexp
and definition_of_sexp__ =
  let _loc = "Xxx.definition"
  in fun sexp -> wrap_of_sexp definitionbis_of_sexp sexp
and definition_of_sexp sexp =
  try definition_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and definitionbis_of_sexp__ =
  let _loc = "Xxx.definitionbis"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let f_name_field = ref None and f_type_field = ref None
        and f_storage_field = ref None and f_body_field = ref None
        and f_attr_field = ref None and f_old_c_style_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "f_name" ->
                     (match !f_name_field with
                      | None ->
                          let fvalue = name_of_sexp field_sexp
                          in f_name_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "f_type" ->
                     (match !f_type_field with
                      | None ->
                          let fvalue = functionType_of_sexp field_sexp
                          in f_type_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "f_storage" ->
                     (match !f_storage_field with
                      | None ->
                          let fvalue = storage_of_sexp field_sexp
                          in f_storage_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "f_body" ->
                     (match !f_body_field with
                      | None ->
                          let fvalue = compound_of_sexp field_sexp
                          in f_body_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "f_attr" ->
                     (match !f_attr_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp attribute_of_sexp field_sexp
                          in f_attr_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "f_old_c_style" ->
                     (match !f_old_c_style_field with
                      | None ->
                          let fvalue =
                            Conv.option_of_sexp
                              (Conv.list_of_sexp declaration_of_sexp)
                              field_sexp
                          in f_old_c_style_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!f_name_field), (!f_type_field), (!f_storage_field),
                       (!f_body_field), (!f_attr_field),
                       (!f_old_c_style_field))
                with
                | (Some f_name_value, Some f_type_value,
                   Some f_storage_value, Some f_body_value,
                   Some f_attr_value, Some f_old_c_style_value) ->
                    {
                      f_name = f_name_value;
                      f_type = f_type_value;
                      f_storage = f_storage_value;
                      f_body = f_body_value;
                      f_attr = f_attr_value;
                      f_old_c_style = f_old_c_style_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!f_name_field = None), "f_name");
                        ((!f_type_field = None), "f_type");
                        ((!f_storage_field = None), "f_storage");
                        ((!f_body_field = None), "f_body");
                        ((!f_attr_field = None), "f_attr");
                        ((!f_old_c_style_field = None), "f_old_c_style") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and definitionbis_of_sexp sexp = definitionbis_of_sexp__ sexp
and cpp_directive_of_sexp__ =
  let _loc = "Xxx.cpp_directive"
  in
    function
    | (Sexp.List (Sexp.Atom (("define" | "Define" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = define_of_sexp v1 in Define v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("include" | "Include" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = includ_of_sexp v1 in Include v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("undef" | "Undef" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = wrap_of_sexp Conv.string_of_sexp v1 in Undef v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("pragmaAndCo" | "PragmaAndCo" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = il_of_sexp v1 in PragmaAndCo v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("define" | "Define") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("include" | "Include") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("undef" | "Undef") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("pragmaAndCo" | "PragmaAndCo") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and cpp_directive_of_sexp sexp = cpp_directive_of_sexp__ sexp
and define_of_sexp__ =
  let _loc = "Xxx.define"
  in
    function
    | Sexp.List ([ v1; v2 ]) ->
        let v1 = wrap_of_sexp Conv.string_of_sexp v1
        and v2 =
          (match v2 with
           | Sexp.List ([ v1; v2 ]) ->
               let v1 = define_kind_of_sexp v1
               and v2 = define_val_of_sexp v2
               in (v1, v2)
           | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
        in (v1, v2)
    | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp
and define_of_sexp sexp =
  try define_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and define_kind_of_sexp__ =
  let _loc = "Xxx.define_kind"
  in
    function
    | Sexp.Atom ("defineVar" | "DefineVar") -> DefineVar
    | (Sexp.List
         (Sexp.Atom (("defineFunc" | "DefineFunc" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (Conv.list_of_sexp
                    (wrap2_of_sexp (wrap_of_sexp Conv.string_of_sexp)))
                 v1
             in DefineFunc v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom ("defineVar" | "DefineVar") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.Atom ("defineFunc" | "DefineFunc") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and define_kind_of_sexp sexp = define_kind_of_sexp__ sexp
and define_val_of_sexp__ =
  let _loc = "Xxx.define_val"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("defineExpr" | "DefineExpr" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in DefineExpr v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineStmt" | "DefineStmt" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = statement_of_sexp v1 in DefineStmt v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineType" | "DefineType" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in DefineType v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineDoWhileZero" | "DefineDoWhileZero" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (function
                  | Sexp.List ([ v1; v2 ]) ->
                      let v1 = statement_of_sexp v1
                      and v2 = expression_of_sexp v2
                      in (v1, v2)
                  | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
                 v1
             in DefineDoWhileZero v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineFunction" | "DefineFunction" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = definition_of_sexp v1 in DefineFunction v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineInit" | "DefineInit" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = initialiser_of_sexp v1 in DefineInit v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("defineText" | "DefineText" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = wrap_of_sexp Conv.string_of_sexp v1 in DefineText v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | Sexp.Atom ("defineEmpty" | "DefineEmpty") -> DefineEmpty
    | Sexp.Atom ("defineTodo" | "DefineTodo") -> DefineTodo
    | (Sexp.Atom ("defineExpr" | "DefineExpr") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineStmt" | "DefineStmt") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineType" | "DefineType") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineDoWhileZero" | "DefineDoWhileZero") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineFunction" | "DefineFunction") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineInit" | "DefineInit") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("defineText" | "DefineText") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.Atom ("defineEmpty" | "DefineEmpty") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("defineTodo" | "DefineTodo") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and define_val_of_sexp sexp = define_val_of_sexp__ sexp
and includ_of_sexp__ =
  let _loc = "Xxx.includ"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let i_include_field = ref None and i_rel_pos_field = ref None
        and i_is_in_ifdef_field = ref None and i_content_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "i_include" ->
                     (match !i_include_field with
                      | None ->
                          let fvalue =
                            wrap_of_sexp inc_file_of_sexp field_sexp
                          in i_include_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "i_rel_pos" ->
                     (match !i_rel_pos_field with
                      | None ->
                          let fvalue =
                            Conv.ref_of_sexp
                              (Conv.option_of_sexp include_rel_pos_of_sexp)
                              field_sexp
                          in i_rel_pos_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "i_is_in_ifdef" ->
                     (match !i_is_in_ifdef_field with
                      | None ->
                          let fvalue = Conv.bool_of_sexp field_sexp
                          in i_is_in_ifdef_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "i_content" ->
                     (match !i_content_field with
                      | None ->
                          let fvalue =
                            Conv.option_of_sexp
                              (function
                               | Sexp.List ([ v1; v2 ]) ->
                                   let v1 = Common.filename_of_sexp v1
                                   and v2 = program_of_sexp v2
                                   in (v1, v2)
                               | sexp ->
                                   Conv_error.tuple_of_size_n_expected _loc 2
                                     sexp)
                              field_sexp
                          in i_content_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!i_include_field), (!i_rel_pos_field),
                       (!i_is_in_ifdef_field), (!i_content_field))
                with
                | (Some i_include_value, Some i_rel_pos_value,
                   Some i_is_in_ifdef_value, Some i_content_value) ->
                    {
                      i_include = i_include_value;
                      i_rel_pos = i_rel_pos_value;
                      i_is_in_ifdef = i_is_in_ifdef_value;
                      i_content = i_content_value;
                    }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!i_include_field = None), "i_include");
                        ((!i_rel_pos_field = None), "i_rel_pos");
                        ((!i_is_in_ifdef_field = None), "i_is_in_ifdef");
                        ((!i_content_field = None), "i_content") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and includ_of_sexp sexp = includ_of_sexp__ sexp
and inc_file_of_sexp__ =
  let _loc = "Xxx.inc_file"
  in
    function
    | (Sexp.List (Sexp.Atom (("local" | "Local" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = Conv.list_of_sexp inc_elem_of_sexp v1 in Local v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("nonLocal" | "NonLocal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = Conv.list_of_sexp inc_elem_of_sexp v1 in NonLocal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("weird" | "Weird" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in Weird v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("local" | "Local") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("nonLocal" | "NonLocal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("weird" | "Weird") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and inc_file_of_sexp sexp = inc_file_of_sexp__ sexp
and inc_elem_of_sexp__ =
  let _loc = "Xxx.inc_elem" in fun sexp -> Conv.string_of_sexp sexp
and inc_elem_of_sexp sexp =
  try inc_elem_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and include_rel_pos_of_sexp__ =
  let _loc = "Xxx.include_rel_pos"
  in
    function
    | (Sexp.List field_sexps as sexp) ->
        let first_of_field = ref None and last_of_field = ref None
        and duplicates = ref [] and extra = ref [] in
        let rec iter =
          (function
           | Sexp.List ([ Sexp.Atom field_name; field_sexp ]) :: tail ->
               ((match field_name with
                 | "first_of" ->
                     (match !first_of_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp
                              (Conv.list_of_sexp Conv.string_of_sexp)
                              field_sexp
                          in first_of_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "last_of" ->
                     (match !last_of_field with
                      | None ->
                          let fvalue =
                            Conv.list_of_sexp
                              (Conv.list_of_sexp Conv.string_of_sexp)
                              field_sexp
                          in last_of_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | sexp :: _ -> Conv_error.record_only_pairs_expected _loc sexp
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Conv_error.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Conv_error.record_extra_fields _loc !extra sexp
             else
               (match ((!first_of_field), (!last_of_field)) with
                | (Some first_of_value, Some last_of_value) ->
                    { first_of = first_of_value; last_of = last_of_value; }
                | _ ->
                    Conv_error.record_undefined_elements _loc sexp
                      [ ((!first_of_field = None), "first_of");
                        ((!last_of_field = None), "last_of") ]))
    | (Sexp.Atom _ as sexp) -> Conv_error.record_list_instead_atom _loc sexp
and include_rel_pos_of_sexp sexp = include_rel_pos_of_sexp__ sexp
and ifdef_directive_of_sexp__ =
  let _loc = "Xxx.ifdef_directive"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("ifdefDirective" | "IfdefDirective" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               wrap_of_sexp
                 (function
                  | Sexp.List ([ v1; v2 ]) ->
                      let v1 = ifdefkind_of_sexp v1
                      and v2 = matching_tag_of_sexp v2
                      in (v1, v2)
                  | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
                 v1
             in IfdefDirective v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("ifdefDirective" | "IfdefDirective") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and ifdef_directive_of_sexp sexp = ifdef_directive_of_sexp__ sexp
and ifdefkind_of_sexp__ =
  let _loc = "Xxx.ifdefkind"
  in
    function
    | Sexp.Atom ("ifdef" | "Ifdef") -> Ifdef
    | Sexp.Atom ("ifdefElseif" | "IfdefElseif") -> IfdefElseif
    | Sexp.Atom ("ifdefElse" | "IfdefElse") -> IfdefElse
    | Sexp.Atom ("ifdefEndif" | "IfdefEndif") -> IfdefEndif
    | (Sexp.List (Sexp.Atom ("ifdef" | "Ifdef") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("ifdefElseif" | "IfdefElseif") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("ifdefElse" | "IfdefElse") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.Atom ("ifdefEndif" | "IfdefEndif") :: _) as sexp) ->
        Conv_error.stag_no_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and ifdefkind_of_sexp sexp = ifdefkind_of_sexp__ sexp
and matching_tag_of_sexp__ =
  let _loc = "Xxx.matching_tag"
  in
    function
    | (Sexp.List (Sexp.Atom (("ifdefTag" | "IfdefTag" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               (match v1 with
                | Sexp.List ([ v1; v2 ]) ->
                    let v1 = Conv.int_of_sexp v1
                    and v2 = Conv.int_of_sexp v2
                    in (v1, v2)
                | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
             in IfdefTag v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("ifdefTag" | "IfdefTag") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and matching_tag_of_sexp sexp = matching_tag_of_sexp__ sexp
and toplevel_of_sexp__ =
  let _loc = "Xxx.toplevel"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("declaration" | "Declaration" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = declaration_of_sexp v1 in Declaration v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("definition" | "Definition" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = definition_of_sexp v1 in Definition v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("cppTop" | "CppTop" as tag)) :: sexp_args) as
       sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = cpp_directive_of_sexp v1 in CppTop v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("ifdefTop" | "IfdefTop" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = ifdef_directive_of_sexp v1 in IfdefTop v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("macroTop" | "MacroTop" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1; v2; v3 ] ->
             let v1 = Conv.string_of_sexp v1
             and v2 = Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v2
             and v3 = il_of_sexp v3
             in MacroTop ((v1, v2, v3))
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("emptyDef" | "EmptyDef" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = il_of_sexp v1 in EmptyDef v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("notParsedCorrectly" | "NotParsedCorrectly" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = il_of_sexp v1 in NotParsedCorrectly v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List (Sexp.Atom (("finalDef" | "FinalDef" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = info_of_sexp v1 in FinalDef v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("declaration" | "Declaration") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("definition" | "Definition") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("cppTop" | "CppTop") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("ifdefTop" | "IfdefTop") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("macroTop" | "MacroTop") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("emptyDef" | "EmptyDef") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("notParsedCorrectly" | "NotParsedCorrectly") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("finalDef" | "FinalDef") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and toplevel_of_sexp sexp = toplevel_of_sexp__ sexp
and program_of_sexp__ =
  let _loc = "Xxx.program"
  in fun sexp -> Conv.list_of_sexp toplevel_of_sexp sexp
and program_of_sexp sexp =
  try program_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp



(*
and metavars_binding_of_sexp__ =
  let _loc = "Xxx.metavars_binding"
  in
    fun sexp ->
      (*
      Common.assoc_of_sexp Ast_cocci.meta_name_of_sexp metavar_binding_kind_of_sexp
        sexp
      *)
      failwith "Todo"
and metavars_binding_of_sexp sexp =
  try metavars_binding_of_sexp__ sexp
  with
  | Conv_error.No_variant_match ((msg, sexp)) -> Conv.of_sexp_error msg sexp
and metavar_binding_kind_of_sexp__ =
  let _loc = "Xxx.metavar_binding_kind"
  in
    function
    | (Sexp.List
         (Sexp.Atom (("metaIdVal" | "MetaIdVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in MetaIdVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaFuncVal" | "MetaFuncVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in MetaFuncVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaLocalFuncVal" | "MetaLocalFuncVal" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.string_of_sexp v1 in MetaLocalFuncVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaExprVal" | "MetaExprVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = expression_of_sexp v1 in MetaExprVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaExprListVal" | "MetaExprListVal" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 = Conv.list_of_sexp (wrap2_of_sexp argument_of_sexp) v1
             in MetaExprListVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaParamVal" | "MetaParamVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = parameterType_of_sexp v1 in MetaParamVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaParamListVal" | "MetaParamListVal" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               Conv.list_of_sexp (wrap2_of_sexp parameterType_of_sexp) v1
             in MetaParamListVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaTypeVal" | "MetaTypeVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = fullType_of_sexp v1 in MetaTypeVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaInitVal" | "MetaInitVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = initialiser_of_sexp v1 in MetaInitVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaDeclVal" | "MetaDeclVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = declaration_of_sexp v1 in MetaDeclVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaFieldVal" | "MetaFieldVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = field_of_sexp v1 in MetaDeclVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaStmtVal" | "MetaStmtVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = statement_of_sexp v1 in MetaStmtVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaPosVal" | "MetaPosVal" as tag)) :: sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               (match v1 with
                | Sexp.List ([ v1; v2 ]) ->
                    let v1 = Ast_cocci.fixpos_of_sexp v1
                    and v2 = Ast_cocci.fixpos_of_sexp v2
                    in (v1, v2)
                | sexp -> Conv_error.tuple_of_size_n_expected _loc 2 sexp)
             in MetaPosVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaPosValList" | "MetaPosValList" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] ->
             let v1 =
               Conv.list_of_sexp
                 (function
                  | Sexp.List ([ v1; v2; v3; v4 ]) ->
                      let v1 = Common.filename_of_sexp v1
                      and v2 = Conv.string_of_sexp v2
                      and v3 = posl_of_sexp v3
                      and v4 = posl_of_sexp v4
                      in (v1, v2, v3, v4)
                  | sexp -> Conv_error.tuple_of_size_n_expected _loc 4 sexp)
                 v1
             in MetaPosValList v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.List
         (Sexp.Atom (("metaListlenVal" | "MetaListlenVal" as tag)) ::
            sexp_args)
       as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Conv.int_of_sexp v1 in MetaListlenVal v1
         | _ -> Conv_error.stag_incorrect_n_args _loc tag sexp)
    | (Sexp.Atom ("metaIdVal" | "MetaIdVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaFuncVal" | "MetaFuncVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaLocalFuncVal" | "MetaLocalFuncVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaExprVal" | "MetaExprVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaExprListVal" | "MetaExprListVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaParamVal" | "MetaParamVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaParamListVal" | "MetaParamListVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaTypeVal" | "MetaTypeVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaInitVal" | "MetaInitVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaStmtVal" | "MetaStmtVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaPosVal" | "MetaPosVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaPosValList" | "MetaPosValList") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.Atom ("metaListlenVal" | "MetaListlenVal") as sexp) ->
        Conv_error.stag_takes_args _loc sexp
    | (Sexp.List (Sexp.List _ :: _) as sexp) ->
        Conv_error.nested_list_invalid_sum _loc sexp
    | (Sexp.List [] as sexp) -> Conv_error.empty_list_invalid_sum _loc sexp
    | sexp -> Conv_error.unexpected_stag _loc sexp
and metavar_binding_kind_of_sexp sexp = metavar_binding_kind_of_sexp__ sexp

*)



let rec
  sexp_of_info {
                 pinfo = v_pinfo;
                 cocci_tag = v_cocci_tag;
                 comments_tag = v_comments_tag
               } =
  if not !show_info then Sexp.Atom ""
  else
  let bnds = [] in
  let arg = Conv.sexp_of_ref sexp_of_comments_around v_comments_tag in
  let bnd = Sexp.List [ Sexp.Atom "comments_tag"; arg ] in
  let bnds = bnd :: bnds in
  let arg =
    Conv.sexp_of_ref
      (Conv.sexp_of_option
         (fun (v1, v2) ->
            let v1 = Ast_cocci.sexp_of_mcodekind v1
            and v2 = (* sexp_of_metavars_binding v2 *) failwith "todo"
            in Sexp.List [ v1; v2 ]))
      v_cocci_tag in
  let bnd = Sexp.List [ Sexp.Atom "cocci_tag"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_parse_info v_pinfo in
  let bnd = Sexp.List [ Sexp.Atom "pinfo"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_il v = Conv.sexp_of_list sexp_of_info v
and sexp_of_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = sexp_of_il v2 in Sexp.List [ v1; v2 ]
and sexp_of_wrap2 _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = sexp_of_il v2 in Sexp.List [ v1; v2 ]


and
  sexp_of_comments_around {
                            mbefore = v_mbefore;
                            mafter = v_mafter;
                            mbefore2 = v_mbefore2;
                            mafter2 = v_mafter2
                          } =
  let bnds = [] in
  let arg = Conv.sexp_of_list sexp_of_comment_and_relative_pos v_mafter2 in
  let bnd = Sexp.List [ Sexp.Atom "mafter2"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_list sexp_of_comment_and_relative_pos v_mbefore2 in
  let bnd = Sexp.List [ Sexp.Atom "mbefore2"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_list Token_c.sexp_of_comment_like_token v_mafter in
  let bnd = Sexp.List [ Sexp.Atom "mafter"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_list Token_c.sexp_of_comment_like_token v_mbefore in
  let bnd = Sexp.List [ Sexp.Atom "mbefore"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_comment_and_relative_pos { minfo = v_minfo; mpos = v_mpos } =
  let bnds = [] in
  let arg = Conv.sexp_of_int v_mpos in
  let bnd = Sexp.List [ Sexp.Atom "mpos"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Common.sexp_of_parse_info v_minfo in
  let bnd = Sexp.List [ Sexp.Atom "minfo"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_comment v = Common.sexp_of_parse_info v
and sexp_of_com v = Conv.sexp_of_ref (Conv.sexp_of_list sexp_of_comment) v




(* break let rec  *)
let rec sexp_of_name =
  function
  | RegularName v1 ->
      let v1 = sexp_of_wrap Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "RegularName"; v1 ]
  | CppConcatenatedName v1 ->
      let v1 =
        Conv.sexp_of_list (sexp_of_wrap2 (sexp_of_wrap Conv.sexp_of_string))
          v1
      in Sexp.List [ Sexp.Atom "CppConcatenatedName"; v1 ]
  | CppVariadicName v1 ->
      let v1 = sexp_of_wrap Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "CppVariadicName"; v1 ]
  | CppIdentBuilder ((v1, v2)) ->
      let v1 = sexp_of_wrap Conv.sexp_of_string v1
      and v2 =
        Conv.sexp_of_list (sexp_of_wrap2 (sexp_of_wrap Conv.sexp_of_string))
          v2
      in Sexp.List [ Sexp.Atom "CppIdentBuilder"; v1; v2 ]
and sexp_of_fullType (v1, v2) =
  let v1 = sexp_of_typeQualifier v1
  and v2 = sexp_of_typeC v2
  in Sexp.List [ v1; v2 ]
and sexp_of_typeC v = sexp_of_wrap sexp_of_typeCbis v
and sexp_of_typeCbis =
  function
  | BaseType v1 ->
      let v1 = sexp_of_baseType v1 in Sexp.List [ Sexp.Atom "BaseType"; v1 ]
  | Pointer v1 ->
      let v1 = sexp_of_fullType v1 in Sexp.List [ Sexp.Atom "Pointer"; v1 ]
  | Array ((v1, v2)) ->
      let v1 = Conv.sexp_of_option sexp_of_constExpression v1
      and v2 = sexp_of_fullType v2
      in Sexp.List [ Sexp.Atom "Array"; v1; v2 ]
  | FunctionType v1 ->
      let v1 = sexp_of_functionType v1
      in Sexp.List [ Sexp.Atom "FunctionType"; v1 ]
  | Enum ((v1, v2)) ->
      let v1 = Conv.sexp_of_option Conv.sexp_of_string v1
      and v2 = sexp_of_enumType v2
      in Sexp.List [ Sexp.Atom "Enum"; v1; v2 ]
  | StructUnion ((v1, v2, v3)) ->
      let v1 = sexp_of_structUnion v1
      and v2 = Conv.sexp_of_option Conv.sexp_of_string v2
      and v3 = sexp_of_structType v3
      in Sexp.List [ Sexp.Atom "StructUnion"; v1; v2; v3 ]
  | EnumName v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "EnumName"; v1 ]
  | StructUnionName ((v1, v2)) ->
      let v1 = sexp_of_structUnion v1
      and v2 = Conv.sexp_of_string v2
      in Sexp.List [ Sexp.Atom "StructUnionName"; v1; v2 ]
  | TypeName ((v1, v2)) ->
      let v1 = sexp_of_name v1
      and v2 = Conv.sexp_of_option sexp_of_fullType v2
      in Sexp.List [ Sexp.Atom "TypeName"; v1; v2 ]
  | ParenType v1 ->
      let v1 = sexp_of_fullType v1 in Sexp.List [ Sexp.Atom "ParenType"; v1 ]
  | TypeOfExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "TypeOfExpr"; v1 ]
  | TypeOfType v1 ->
      let v1 = sexp_of_fullType v1
      in Sexp.List [ Sexp.Atom "TypeOfType"; v1 ]
and sexp_of_baseType =
  function
  | Void -> Sexp.Atom "Void"
  | IntType v1 ->
      let v1 = sexp_of_intType v1 in Sexp.List [ Sexp.Atom "IntType"; v1 ]
  | FloatType v1 ->
      let v1 = sexp_of_floatType v1
      in Sexp.List [ Sexp.Atom "FloatType"; v1 ]
and sexp_of_intType =
  function
  | CChar -> Sexp.Atom "CChar"
  | Si v1 -> let v1 = sexp_of_signed v1 in Sexp.List [ Sexp.Atom "Si"; v1 ]
and sexp_of_signed (v1, v2) =
  let v1 = sexp_of_sign v1 and v2 = sexp_of_base v2 in Sexp.List [ v1; v2 ]
and sexp_of_base =
  function
  | CChar2 -> Sexp.Atom "CChar2"
  | CShort -> Sexp.Atom "CShort"
  | CInt -> Sexp.Atom "CInt"
  | CLong -> Sexp.Atom "CLong"
  | CLongLong -> Sexp.Atom "CLongLong"
and sexp_of_sign =
  function | Signed -> Sexp.Atom "Signed" | UnSigned -> Sexp.Atom "UnSigned"
and sexp_of_floatType =
  function
  | CFloat -> Sexp.Atom "CFloat"
  | CDouble -> Sexp.Atom "CDouble"
  | CLongDouble -> Sexp.Atom "CLongDouble"
and sexp_of_structUnion =
  function | Struct -> Sexp.Atom "Struct" | Union -> Sexp.Atom "Union"
and sexp_of_structType v = Conv.sexp_of_list sexp_of_field v
and sexp_of_field =
  function
  | DeclarationField v1 ->
      let v1 = sexp_of_field_declaration v1
      in Sexp.List [ Sexp.Atom "DeclarationField"; v1 ]
  | EmptyField v1 ->
      let v1 = sexp_of_info v1 in Sexp.List [ Sexp.Atom "EmptyField"; v1 ]
  | MacroDeclField v1 ->
      let v1 =
        sexp_of_wrap
          (fun (v1, v2) ->
             let v1 = Conv.sexp_of_string v1
             and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v2
             in Sexp.List [ v1; v2 ])
          v1
      in Sexp.List [ Sexp.Atom "MacroDeclField"; v1 ]
  | CppDirectiveStruct v1 ->
      let v1 = sexp_of_cpp_directive v1
      in Sexp.List [ Sexp.Atom "CppDirectiveStruct"; v1 ]
  | IfdefStruct v1 ->
      let v1 = sexp_of_ifdef_directive v1
      in Sexp.List [ Sexp.Atom "IfdefStruct"; v1 ]
and sexp_of_field_declaration =
  function
  | FieldDeclList v1 ->
      let v1 =
        sexp_of_wrap (Conv.sexp_of_list (sexp_of_wrap2 sexp_of_fieldkind)) v1
      in Sexp.List [ Sexp.Atom "FieldDeclList"; v1 ]
and sexp_of_fieldkind =
  function
  | Simple ((v1, v2)) ->
      let v1 = Conv.sexp_of_option sexp_of_name v1
      and v2 = sexp_of_fullType v2
      in Sexp.List [ Sexp.Atom "Simple"; v1; v2 ]
  | BitField ((v1, v2, v3, v4)) ->
      let v1 = Conv.sexp_of_option sexp_of_name v1
      and v2 = sexp_of_fullType v2
      and v3 = sexp_of_info v3
      and v4 = sexp_of_constExpression v4
      in Sexp.List [ Sexp.Atom "BitField"; v1; v2; v3; v4 ]
and sexp_of_enumType v =
  Conv.sexp_of_list
    (sexp_of_wrap2
       (fun (v1, v2) ->
          let v1 = sexp_of_name v1
          and v2 =
            Conv.sexp_of_option
              (fun (v1, v2) ->
                 let v1 = sexp_of_info v1
                 and v2 = sexp_of_constExpression v2
                 in Sexp.List [ v1; v2 ])
              v2
          in Sexp.List [ v1; v2 ]))
    v
and sexp_of_functionType (v1, v2) =
  let v1 = sexp_of_fullType v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_parameterType) v1
        and v2 = sexp_of_wrap Conv.sexp_of_bool v2
        in Sexp.List [ v1; v2 ]
  in Sexp.List [ v1; v2 ]
and
  sexp_of_parameterType {
                          p_namei = v_p_namei;
                          p_register = v_p_register;
                          p_type = v_p_type
                        } =
  let bnds = [] in
  let arg = sexp_of_fullType v_p_type in
  let bnd = Sexp.List [ Sexp.Atom "p_type"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_wrap Conv.sexp_of_bool v_p_register in
  let bnd = Sexp.List [ Sexp.Atom "p_register"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_option sexp_of_name v_p_namei in
  let bnd = Sexp.List [ Sexp.Atom "p_namei"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_typeQualifier v = sexp_of_wrap sexp_of_typeQualifierbis v
and sexp_of_typeQualifierbis { const = v_const; volatile = v_volatile } =
  if not !show_qualifier then Sexp.Atom ""
  else
  let bnds = [] in
  let arg = Conv.sexp_of_bool v_volatile in
  let bnd = Sexp.List [ Sexp.Atom "volatile"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_bool v_const in
  let bnd = Sexp.List [ Sexp.Atom "const"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_attribute v = sexp_of_wrap sexp_of_attributebis v
and sexp_of_attributebis =
  function
  | Attribute v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "Attribute"; v1 ]
and sexp_of_expression v =
  sexp_of_wrap
    (fun (v1, v2) ->
       let v1 = sexp_of_expressionbis v1
       and v2 =
         if not !show_expr_info then Sexp.Atom ""
         else Conv.sexp_of_ref sexp_of_exp_info v2
       in Sexp.List [ v1; v2 ])
    v
and sexp_of_exp_info (v1, v2) =
  let v1 = Conv.sexp_of_option sexp_of_exp_type v1
  and v2 = sexp_of_test v2
  in Sexp.List [ v1; v2 ]
and sexp_of_exp_type (v1, v2) =
  let v1 = sexp_of_fullType v1
  and v2 = sexp_of_local v2
  in Sexp.List [ v1; v2 ]
and sexp_of_local =
  function
  | LocalVar v1 ->
      let v1 = sexp_of_parse_info v1
      in Sexp.List [ Sexp.Atom "LocalVar"; v1 ]
  | NotLocalVar -> Sexp.Atom "NotLocalVar"
and sexp_of_test =
  function | Test -> Sexp.Atom "Test" | NotTest -> Sexp.Atom "NotTest"
and sexp_of_expressionbis =
  function
  | Ident v1 ->
      let v1 = sexp_of_name v1 in Sexp.List [ Sexp.Atom "Ident"; v1 ]
  | Constant v1 ->
      let v1 = sexp_of_constant v1 in Sexp.List [ Sexp.Atom "Constant"; v1 ]
  | FunCall ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v2
      in Sexp.List [ Sexp.Atom "FunCall"; v1; v2 ]
  | CondExpr ((v1, v2, v3)) ->
      let v1 = sexp_of_expression v1
      and v2 = Conv.sexp_of_option sexp_of_expression v2
      and v3 = sexp_of_expression v3
      in Sexp.List [ Sexp.Atom "CondExpr"; v1; v2; v3 ]
  | Sequence ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_expression v2
      in Sexp.List [ Sexp.Atom "Sequence"; v1; v2 ]
  | Assignment ((v1, v2, v3)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_assignOp v2
      and v3 = sexp_of_expression v3
      in Sexp.List [ Sexp.Atom "Assignment"; v1; v2; v3 ]
  | Postfix ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_fixOp v2
      in Sexp.List [ Sexp.Atom "Postfix"; v1; v2 ]
  | Infix ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_fixOp v2
      in Sexp.List [ Sexp.Atom "Infix"; v1; v2 ]
  | Unary ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_unaryOp v2
      in Sexp.List [ Sexp.Atom "Unary"; v1; v2 ]
  | Binary ((v1, v2, v3)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_binaryOp v2
      and v3 = sexp_of_expression v3
      in Sexp.List [ Sexp.Atom "Binary"; v1; v2; v3 ]
  | ArrayAccess ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_expression v2
      in Sexp.List [ Sexp.Atom "ArrayAccess"; v1; v2 ]
  | RecordAccess ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_name v2
      in Sexp.List [ Sexp.Atom "RecordAccess"; v1; v2 ]
  | RecordPtAccess ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_name v2
      in Sexp.List [ Sexp.Atom "RecordPtAccess"; v1; v2 ]
  | SizeOfExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "SizeOfExpr"; v1 ]
  | SizeOfType v1 ->
      let v1 = sexp_of_fullType v1
      in Sexp.List [ Sexp.Atom "SizeOfType"; v1 ]
  | Cast ((v1, v2)) ->
      let v1 = sexp_of_fullType v1
      and v2 = sexp_of_expression v2
      in Sexp.List [ Sexp.Atom "Cast"; v1; v2 ]
  | StatementExpr v1 ->
      let v1 = sexp_of_wrap sexp_of_compound v1
      in Sexp.List [ Sexp.Atom "StatementExpr"; v1 ]
  | Constructor ((v1, v2)) ->
      let v1 = sexp_of_fullType v1
      and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_initialiser) v2
      in Sexp.List [ Sexp.Atom "Constructor"; v1; v2 ]
  | ParenExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "ParenExpr"; v1 ]
and sexp_of_argument v =
  Common.sexp_of_either sexp_of_expression sexp_of_weird_argument v
and sexp_of_weird_argument =
  function
  | ArgType v1 ->
      let v1 = sexp_of_parameterType v1
      in Sexp.List [ Sexp.Atom "ArgType"; v1 ]
  | ArgAction v1 ->
      let v1 = sexp_of_action_macro v1
      in Sexp.List [ Sexp.Atom "ArgAction"; v1 ]
and sexp_of_action_macro =
  function
  | ActMisc v1 ->
      let v1 = sexp_of_il v1 in Sexp.List [ Sexp.Atom "ActMisc"; v1 ]
and sexp_of_constant =
  function
  | String v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Conv.sexp_of_string v1
             and v2 = sexp_of_isWchar v2
             in Sexp.List [ v1; v2 ])
      in Sexp.List [ Sexp.Atom "String"; v1 ]
  | MultiString v1 ->
      let v1 = Conv.sexp_of_list Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "MultiString"; v1 ]
  | Char v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Conv.sexp_of_string v1
             and v2 = sexp_of_isWchar v2
             in Sexp.List [ v1; v2 ])
      in Sexp.List [ Sexp.Atom "Char"; v1 ]
  | Int (v1, _todo) ->
      let v1 = Conv.sexp_of_string v1 in Sexp.List [ Sexp.Atom "Int"; v1 ]
  | Float v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Conv.sexp_of_string v1
             and v2 = sexp_of_floatType v2
             in Sexp.List [ v1; v2 ])
      in Sexp.List [ Sexp.Atom "Float"; v1 ]
and sexp_of_isWchar =
  function | IsWchar -> Sexp.Atom "IsWchar" | IsChar -> Sexp.Atom "IsChar"
and sexp_of_unaryOp =
  function
  | GetRef -> Sexp.Atom "GetRef"
  | DeRef -> Sexp.Atom "DeRef"
  | UnPlus -> Sexp.Atom "UnPlus"
  | UnMinus -> Sexp.Atom "UnMinus"
  | Tilde -> Sexp.Atom "Tilde"
  | Not -> Sexp.Atom "Not"
  | GetRefLabel -> Sexp.Atom "GetRefLabel"
and sexp_of_assignOp =
  function
  | SimpleAssign -> Sexp.Atom "SimpleAssign"
  | OpAssign v1 ->
      let v1 = sexp_of_arithOp v1 in Sexp.List [ Sexp.Atom "OpAssign"; v1 ]
and sexp_of_fixOp =
  function | Dec -> Sexp.Atom "Dec" | Inc -> Sexp.Atom "Inc"
and sexp_of_binaryOp =
  function
  | Arith v1 ->
      let v1 = sexp_of_arithOp v1 in Sexp.List [ Sexp.Atom "Arith"; v1 ]
  | Logical v1 ->
      let v1 = sexp_of_logicalOp v1 in Sexp.List [ Sexp.Atom "Logical"; v1 ]
and sexp_of_arithOp =
  function
  | Plus -> Sexp.Atom "Plus"
  | Minus -> Sexp.Atom "Minus"
  | Mul -> Sexp.Atom "Mul"
  | Div -> Sexp.Atom "Div"
  | Mod -> Sexp.Atom "Mod"
  | DecLeft -> Sexp.Atom "DecLeft"
  | DecRight -> Sexp.Atom "DecRight"
  | And -> Sexp.Atom "And"
  | Or -> Sexp.Atom "Or"
  | Xor -> Sexp.Atom "Xor"
and sexp_of_logicalOp =
  function
  | Inf -> Sexp.Atom "Inf"
  | Sup -> Sexp.Atom "Sup"
  | InfEq -> Sexp.Atom "InfEq"
  | SupEq -> Sexp.Atom "SupEq"
  | Eq -> Sexp.Atom "Eq"
  | NotEq -> Sexp.Atom "NotEq"
  | AndLog -> Sexp.Atom "AndLog"
  | OrLog -> Sexp.Atom "OrLog"
and sexp_of_constExpression v = sexp_of_expression v
and sexp_of_statement v = sexp_of_wrap sexp_of_statementbis v
and sexp_of_statementbis =
  function
  | Labeled v1 ->
      let v1 = sexp_of_labeled v1 in Sexp.List [ Sexp.Atom "Labeled"; v1 ]
  | Compound v1 ->
      let v1 = sexp_of_compound v1 in Sexp.List [ Sexp.Atom "Compound"; v1 ]
  | ExprStatement v1 ->
      let v1 = sexp_of_exprStatement v1
      in Sexp.List [ Sexp.Atom "ExprStatement"; v1 ]
  | Selection v1 ->
      let v1 = sexp_of_selection v1
      in Sexp.List [ Sexp.Atom "Selection"; v1 ]
  | Iteration v1 ->
      let v1 = sexp_of_iteration v1
      in Sexp.List [ Sexp.Atom "Iteration"; v1 ]
  | Jump v1 -> let v1 = sexp_of_jump v1 in Sexp.List [ Sexp.Atom "Jump"; v1 ]
  | Decl v1 ->
      let v1 = sexp_of_declaration v1 in Sexp.List [ Sexp.Atom "Decl"; v1 ]
  | Asm v1 ->
      let v1 = sexp_of_asmbody v1 in Sexp.List [ Sexp.Atom "Asm"; v1 ]
  | NestedFunc v1 ->
      let v1 = sexp_of_definition v1
      in Sexp.List [ Sexp.Atom "NestedFunc"; v1 ]
  | MacroStmt -> Sexp.Atom "MacroStmt"
and sexp_of_labeled =
  function
  | Label ((v1, v2)) ->
      let v1 = sexp_of_name v1
      and v2 = sexp_of_statement v2
      in Sexp.List [ Sexp.Atom "Label"; v1; v2 ]
  | Case ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_statement v2
      in Sexp.List [ Sexp.Atom "Case"; v1; v2 ]
  | CaseRange ((v1, v2, v3)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_expression v2
      and v3 = sexp_of_statement v3
      in Sexp.List [ Sexp.Atom "CaseRange"; v1; v2; v3 ]
  | Default v1 ->
      let v1 = sexp_of_statement v1 in Sexp.List [ Sexp.Atom "Default"; v1 ]
and sexp_of_compound v = Conv.sexp_of_list sexp_of_statement_sequencable v
and sexp_of_statement_sequencable =
  function
  | StmtElem v1 ->
      let v1 = sexp_of_statement v1 in Sexp.List [ Sexp.Atom "StmtElem"; v1 ]
  | CppDirectiveStmt v1 ->
      let v1 = sexp_of_cpp_directive v1
      in Sexp.List [ Sexp.Atom "CppDirectiveStmt"; v1 ]
  | IfdefStmt v1 ->
      let v1 = sexp_of_ifdef_directive v1
      in Sexp.List [ Sexp.Atom "IfdefStmt"; v1 ]
  | IfdefStmt2 ((v1, v2)) ->
      let v1 = Conv.sexp_of_list sexp_of_ifdef_directive v1
      and v2 =
        Conv.sexp_of_list (Conv.sexp_of_list sexp_of_statement_sequencable)
          v2
      in Sexp.List [ Sexp.Atom "IfdefStmt2"; v1; v2 ]
and sexp_of_exprStatement v = Conv.sexp_of_option sexp_of_expression v
and sexp_of_selection =
  function
  | If ((v1, v2, v3)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_statement v2
      and v3 = sexp_of_statement v3
      in Sexp.List [ Sexp.Atom "If"; v1; v2; v3 ]
  | Switch ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_statement v2
      in Sexp.List [ Sexp.Atom "Switch"; v1; v2 ]
and sexp_of_iteration =
  function
  | While ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_statement v2
      in Sexp.List [ Sexp.Atom "While"; v1; v2 ]
  | DoWhile ((v1, v2)) ->
      let v1 = sexp_of_statement v1
      and v2 = sexp_of_expression v2
      in Sexp.List [ Sexp.Atom "DoWhile"; v1; v2 ]
  | For ((v1, v2, v3, v4)) ->
      let v1 = sexp_of_wrap sexp_of_exprStatement v1
      and v2 = sexp_of_wrap sexp_of_exprStatement v2
      and v3 = sexp_of_wrap sexp_of_exprStatement v3
      and v4 = sexp_of_statement v4
      in Sexp.List [ Sexp.Atom "For"; v1; v2; v3; v4 ]
  | MacroIteration ((v1, v2, v3)) ->
      let v1 = Conv.sexp_of_string v1
      and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v2
      and v3 = sexp_of_statement v3
      in Sexp.List [ Sexp.Atom "MacroIteration"; v1; v2; v3 ]
and sexp_of_jump =
  function
  | Goto v1 -> let v1 = sexp_of_name v1 in Sexp.List [ Sexp.Atom "Goto"; v1 ]
  | Continue -> Sexp.Atom "Continue"
  | Break -> Sexp.Atom "Break"
  | Return -> Sexp.Atom "Return"
  | ReturnExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "ReturnExpr"; v1 ]
  | GotoComputed v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "GotoComputed"; v1 ]
and sexp_of_asmbody (v1, v2) =
  let v1 = sexp_of_il v1
  and v2 = Conv.sexp_of_list (sexp_of_wrap sexp_of_colon) v2
  in Sexp.List [ v1; v2 ]
and sexp_of_colon =
  function
  | Colon v1 ->
      let v1 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_colon_option) v1
      in Sexp.List [ Sexp.Atom "Colon"; v1 ]
and sexp_of_colon_option v = sexp_of_wrap sexp_of_colon_option_bis v
and sexp_of_colon_option_bis =
  function
  | ColonMisc -> Sexp.Atom "ColonMisc"
  | ColonExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "ColonExpr"; v1 ]
and sexp_of_declaration =
  function
  | DeclList v1 ->
      let v1 =
        sexp_of_wrap (Conv.sexp_of_list (sexp_of_wrap2 sexp_of_onedecl)) v1
      in Sexp.List [ Sexp.Atom "DeclList"; v1 ]
  | MacroDecl v1 ->
      let v1 =
        sexp_of_wrap
          (fun (v1, v2) ->
             let v1 = Conv.sexp_of_string v1
             and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v2
             in Sexp.List [ v1; v2 ])
          v1
      in Sexp.List [ Sexp.Atom "MacroDecl"; v1 ]
and
  sexp_of_onedecl {
                    v_namei = v_v_namei;
                    v_type = v_v_type;
                    v_type_bis = v_v_type_bis;
                    v_storage = v_v_storage;
                    v_local = v_v_local;
                    v_attr = v_v_attr
                  } =
  let bnds = [] in
  let arg = Conv.sexp_of_list sexp_of_attribute v_v_attr in
  let bnd = Sexp.List [ Sexp.Atom "v_attr"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_local_decl v_v_local in
  let bnd = Sexp.List [ Sexp.Atom "v_local"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_storage v_v_storage in
  let bnd = Sexp.List [ Sexp.Atom "v_storage"; arg ] in
  let bnds = bnd :: bnds in
  let arg =
    Conv.sexp_of_ref (Conv.sexp_of_option sexp_of_fullType) v_v_type_bis in
  let bnd = Sexp.List [ Sexp.Atom "v_type_bis"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_fullType v_v_type in
  let bnd = Sexp.List [ Sexp.Atom "v_type"; arg ] in
  let bnds = bnd :: bnds in
  let arg =
    Conv.sexp_of_option
      (fun (v1, v2) ->
         let v1 = sexp_of_name v1
         and v2 =
           Conv.sexp_of_option
             (fun (v1, v2) ->
                let v1 = sexp_of_info v1
                and v2 = sexp_of_initialiser v2
                in Sexp.List [ v1; v2 ])
             v2
         in Sexp.List [ v1; v2 ])
      v_v_namei in
  let bnd = Sexp.List [ Sexp.Atom "v_namei"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_storage (v1, v2) =
  let v1 = sexp_of_storagebis v1
  and v2 = Conv.sexp_of_bool v2
  in Sexp.List [ v1; v2 ]
and sexp_of_storagebis =
  function
  | NoSto -> Sexp.Atom "NoSto"
  | StoTypedef -> Sexp.Atom "StoTypedef"
  | Sto v1 ->
      let v1 = sexp_of_storageClass v1 in Sexp.List [ Sexp.Atom "Sto"; v1 ]
and sexp_of_storageClass =
  function
  | Auto -> Sexp.Atom "Auto"
  | Static -> Sexp.Atom "Static"
  | Register -> Sexp.Atom "Register"
  | Extern -> Sexp.Atom "Extern"
and sexp_of_local_decl =
  function
  | LocalDecl -> Sexp.Atom "LocalDecl"
  | NotLocalDecl -> Sexp.Atom "NotLocalDecl"
and sexp_of_initialiser v = sexp_of_wrap sexp_of_initialiserbis v
and sexp_of_initialiserbis =
  function
  | InitExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "InitExpr"; v1 ]
  | InitList v1 ->
      let v1 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_initialiser) v1
      in Sexp.List [ Sexp.Atom "InitList"; v1 ]
  | InitDesignators ((v1, v2)) ->
      let v1 = Conv.sexp_of_list sexp_of_designator v1
      and v2 = sexp_of_initialiser v2
      in Sexp.List [ Sexp.Atom "InitDesignators"; v1; v2 ]
  | InitFieldOld ((v1, v2)) ->
      let v1 = Conv.sexp_of_string v1
      and v2 = sexp_of_initialiser v2
      in Sexp.List [ Sexp.Atom "InitFieldOld"; v1; v2 ]
  | InitIndexOld ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_initialiser v2
      in Sexp.List [ Sexp.Atom "InitIndexOld"; v1; v2 ]
and sexp_of_designator v = sexp_of_wrap sexp_of_designatorbis v
and sexp_of_designatorbis =
  function
  | DesignatorField v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "DesignatorField"; v1 ]
  | DesignatorIndex v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "DesignatorIndex"; v1 ]
  | DesignatorRange ((v1, v2)) ->
      let v1 = sexp_of_expression v1
      and v2 = sexp_of_expression v2
      in Sexp.List [ Sexp.Atom "DesignatorRange"; v1; v2 ]
and sexp_of_definition v = sexp_of_wrap sexp_of_definitionbis v
and
  sexp_of_definitionbis {
                          f_name = v_f_name;
                          f_type = v_f_type;
                          f_storage = v_f_storage;
                          f_body = v_f_body;
                          f_attr = v_f_attr;
                          f_old_c_style = v_f_old_c_style
                        } =
  let bnds = [] in
  let arg =
    Conv.sexp_of_option (Conv.sexp_of_list sexp_of_declaration)
      v_f_old_c_style in
  let bnd = Sexp.List [ Sexp.Atom "f_old_c_style"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_list sexp_of_attribute v_f_attr in
  let bnd = Sexp.List [ Sexp.Atom "f_attr"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_compound v_f_body in
  let bnd = Sexp.List [ Sexp.Atom "f_body"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_storage v_f_storage in
  let bnd = Sexp.List [ Sexp.Atom "f_storage"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_functionType v_f_type in
  let bnd = Sexp.List [ Sexp.Atom "f_type"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_name v_f_name in
  let bnd = Sexp.List [ Sexp.Atom "f_name"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_cpp_directive =
  function
  | Define v1 ->
      let v1 = sexp_of_define v1 in Sexp.List [ Sexp.Atom "Define"; v1 ]
  | Include v1 ->
      let v1 = sexp_of_includ v1 in Sexp.List [ Sexp.Atom "Include"; v1 ]
  | Undef v1 ->
      let v1 = sexp_of_wrap Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "Undef"; v1 ]
  | PragmaAndCo v1 ->
      let v1 = sexp_of_il v1 in Sexp.List [ Sexp.Atom "PragmaAndCo"; v1 ]
and sexp_of_define (v1, v2) =
  let v1 = sexp_of_wrap Conv.sexp_of_string v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = sexp_of_define_kind v1
        and v2 = sexp_of_define_val v2
        in Sexp.List [ v1; v2 ]
  in Sexp.List [ v1; v2 ]
and sexp_of_define_kind =
  function
  | DefineVar -> Sexp.Atom "DefineVar"
  | DefineFunc v1 ->
      let v1 =
        sexp_of_wrap
          (Conv.sexp_of_list
             (sexp_of_wrap2 (sexp_of_wrap Conv.sexp_of_string)))
          v1
      in Sexp.List [ Sexp.Atom "DefineFunc"; v1 ]
and sexp_of_define_val =
  function
  | DefineExpr v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "DefineExpr"; v1 ]
  | DefineStmt v1 ->
      let v1 = sexp_of_statement v1
      in Sexp.List [ Sexp.Atom "DefineStmt"; v1 ]
  | DefineType v1 ->
      let v1 = sexp_of_fullType v1
      in Sexp.List [ Sexp.Atom "DefineType"; v1 ]
  | DefineDoWhileZero v1 ->
      let v1 =
        sexp_of_wrap
          (fun (v1, v2) ->
             let v1 = sexp_of_statement v1
             and v2 = sexp_of_expression v2
             in Sexp.List [ v1; v2 ])
          v1
      in Sexp.List [ Sexp.Atom "DefineDoWhileZero"; v1 ]
  | DefineFunction v1 ->
      let v1 = sexp_of_definition v1
      in Sexp.List [ Sexp.Atom "DefineFunction"; v1 ]
  | DefineInit v1 ->
      let v1 = sexp_of_initialiser v1
      in Sexp.List [ Sexp.Atom "DefineInit"; v1 ]
  | DefineText v1 ->
      let v1 = sexp_of_wrap Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "DefineText"; v1 ]
  | DefineEmpty -> Sexp.Atom "DefineEmpty"
  | DefineTodo -> Sexp.Atom "DefineTodo"
and
  sexp_of_includ {
                   i_include = v_i_include;
                   i_rel_pos = v_i_rel_pos;
                   i_is_in_ifdef = v_i_is_in_ifdef;
                   i_content = v_i_content
                 } =
  let bnds = [] in
  let arg =
    Conv.sexp_of_option
      (fun (v1, v2) ->
         let v1 = Common.sexp_of_filename v1
         and v2 = sexp_of_program v2
         in Sexp.List [ v1; v2 ])
      v_i_content in
  let bnd = Sexp.List [ Sexp.Atom "i_content"; arg ] in
  let bnds = bnd :: bnds in
  let arg = Conv.sexp_of_bool v_i_is_in_ifdef in
  let bnd = Sexp.List [ Sexp.Atom "i_is_in_ifdef"; arg ] in
  let bnds = bnd :: bnds in
  let arg =
    Conv.sexp_of_ref (Conv.sexp_of_option sexp_of_include_rel_pos)
      v_i_rel_pos in
  let bnd = Sexp.List [ Sexp.Atom "i_rel_pos"; arg ] in
  let bnds = bnd :: bnds in
  let arg = sexp_of_wrap sexp_of_inc_file v_i_include in
  let bnd = Sexp.List [ Sexp.Atom "i_include"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_inc_file =
  function
  | Local v1 ->
      let v1 = Conv.sexp_of_list sexp_of_inc_elem v1
      in Sexp.List [ Sexp.Atom "Local"; v1 ]
  | NonLocal v1 ->
      let v1 = Conv.sexp_of_list sexp_of_inc_elem v1
      in Sexp.List [ Sexp.Atom "NonLocal"; v1 ]
  | Weird v1 ->
      let v1 = Conv.sexp_of_string v1 in Sexp.List [ Sexp.Atom "Weird"; v1 ]
and sexp_of_inc_elem v = Conv.sexp_of_string v
and sexp_of_include_rel_pos { first_of = v_first_of; last_of = v_last_of } =
  let bnds = [] in
  let arg =
    Conv.sexp_of_list (Conv.sexp_of_list Conv.sexp_of_string) v_last_of in
  let bnd = Sexp.List [ Sexp.Atom "last_of"; arg ] in
  let bnds = bnd :: bnds in
  let arg =
    Conv.sexp_of_list (Conv.sexp_of_list Conv.sexp_of_string) v_first_of in
  let bnd = Sexp.List [ Sexp.Atom "first_of"; arg ] in
  let bnds = bnd :: bnds in Sexp.List bnds
and sexp_of_ifdef_directive =
  function
  | IfdefDirective v1 ->
      let v1 =
        sexp_of_wrap
          (fun (v1, v2) ->
             let v1 = sexp_of_ifdefkind v1
             and v2 = sexp_of_matching_tag v2
             in Sexp.List [ v1; v2 ])
          v1
      in Sexp.List [ Sexp.Atom "IfdefDirective"; v1 ]
and sexp_of_ifdefkind =
  function
  | Ifdef -> Sexp.Atom "Ifdef"
  | IfdefElseif -> Sexp.Atom "IfdefElseif"
  | IfdefElse -> Sexp.Atom "IfdefElse"
  | IfdefEndif -> Sexp.Atom "IfdefEndif"
and sexp_of_matching_tag =
  function
  | IfdefTag v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Conv.sexp_of_int v1
             and v2 = Conv.sexp_of_int v2
             in Sexp.List [ v1; v2 ])
      in Sexp.List [ Sexp.Atom "IfdefTag"; v1 ]
and sexp_of_toplevel =
  function
  | Declaration v1 ->
      let v1 = sexp_of_declaration v1
      in Sexp.List [ Sexp.Atom "Declaration"; v1 ]
  | Definition v1 ->
      let v1 = sexp_of_definition v1
      in Sexp.List [ Sexp.Atom "Definition"; v1 ]
  | CppTop v1 ->
      let v1 = sexp_of_cpp_directive v1
      in Sexp.List [ Sexp.Atom "CppTop"; v1 ]
  | IfdefTop v1 ->
      let v1 = sexp_of_ifdef_directive v1
      in Sexp.List [ Sexp.Atom "IfdefTop"; v1 ]
  | MacroTop ((v1, v2, v3)) ->
      let v1 = Conv.sexp_of_string v1
      and v2 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v2
      and v3 = sexp_of_il v3
      in Sexp.List [ Sexp.Atom "MacroTop"; v1; v2; v3 ]
  | EmptyDef v1 ->
      let v1 = sexp_of_il v1 in Sexp.List [ Sexp.Atom "EmptyDef"; v1 ]
  | NotParsedCorrectly v1 ->
      let v1 = sexp_of_il v1
      in Sexp.List [ Sexp.Atom "NotParsedCorrectly"; v1 ]
  | FinalDef v1 ->
      let v1 = sexp_of_info v1 in Sexp.List [ Sexp.Atom "FinalDef"; v1 ]
and sexp_of_program v = Conv.sexp_of_list sexp_of_toplevel v

(*
and sexp_of_metavars_binding v =
  failwith "Todo"
(*
  Common.sexp_of_assoc Ast_cocci.sexp_of_meta_name sexp_of_metavar_binding_kind v
*)
and sexp_of_metavar_binding_kind =
  function
  | MetaIdVal v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "MetaIdVal"; v1 ]
  | MetaFuncVal v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "MetaFuncVal"; v1 ]
  | MetaLocalFuncVal v1 ->
      let v1 = Conv.sexp_of_string v1
      in Sexp.List [ Sexp.Atom "MetaLocalFuncVal"; v1 ]
  | MetaExprVal v1 ->
      let v1 = sexp_of_expression v1
      in Sexp.List [ Sexp.Atom "MetaExprVal"; v1 ]
  | MetaExprListVal v1 ->
      let v1 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_argument) v1
      in Sexp.List [ Sexp.Atom "MetaExprListVal"; v1 ]
  | MetaParamVal v1 ->
      let v1 = sexp_of_parameterType v1
      in Sexp.List [ Sexp.Atom "MetaParamVal"; v1 ]
  | MetaParamListVal v1 ->
      let v1 = Conv.sexp_of_list (sexp_of_wrap2 sexp_of_parameterType) v1
      in Sexp.List [ Sexp.Atom "MetaParamListVal"; v1 ]
  | MetaTypeVal v1 ->
      let v1 = sexp_of_fullType v1
      in Sexp.List [ Sexp.Atom "MetaTypeVal"; v1 ]
  | MetaInitVal v1 ->
      let v1 = sexp_of_initialiser v1
      in Sexp.List [ Sexp.Atom "MetaInitVal"; v1 ]
  | MetaStmtVal v1 ->
      let v1 = sexp_of_statement v1
      in Sexp.List [ Sexp.Atom "MetaStmtVal"; v1 ]
  | MetaPosVal v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ast_cocci.sexp_of_fixpos v1
             and v2 = Ast_cocci.sexp_of_fixpos v2
             in Sexp.List [ v1; v2 ])
      in Sexp.List [ Sexp.Atom "MetaPosVal"; v1 ]
  | MetaPosValList v1 ->
      let v1 =
        Conv.sexp_of_list
          (fun (v1, v2, v3, v4) ->
             let v1 = Common.sexp_of_filename v1
             and v2 = Conv.sexp_of_string v2
             and v3 = sexp_of_posl v3
             and v4 = sexp_of_posl v4
             in Sexp.List [ v1; v2; v3; v4 ])
          v1
      in Sexp.List [ Sexp.Atom "MetaPosValList"; v1 ]
  | MetaListlenVal v1 ->
      let v1 = Conv.sexp_of_int v1
      in Sexp.List [ Sexp.Atom "MetaListlenVal"; v1 ]

*)

(* pad: *)
let string_of_toplevel top =
  let sexp = sexp_of_toplevel top in
  let s = Sexp.to_string_hum sexp in
  s

let string_of_expression x =
  let sexp = sexp_of_expression x in
  let s = Sexp.to_string_hum sexp in
  s

let string_of_program xs =
  let sexp = sexp_of_program xs in
  let s = Sexp.to_string_hum sexp in
  s
